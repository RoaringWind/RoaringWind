<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>missing-semester-data-wrangling</title>
    <link href="/2022/05/17/missing-semester-data-wrangling/"/>
    <url>/2022/05/17/missing-semester-data-wrangling/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.gnu.org/software/sed/" target="_blank" rel="noopener">sed</a>: stream editor is a non-interactive command-line text editor.</p><pre><code class="hljs shell">echo 'abcaba' | sed -E 's/(ab)*//g' # ca. -E 表示现代版本的正则表达式，不加可能会出错。</code></pre><pre><code class="hljs shell">ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' | less # 使用''包括命令，使得命令可在远端执行后再返回，节省带宽。</code></pre><p>一个学习正则表达式的网站：<a href="https://regexone.com/lesson/misc_meta_characters?" target="_blank" rel="noopener">RegexOne</a></p><p>一个正则表达式解析的网站：<a href="https://regex101.com/" target="_blank" rel="noopener">Regex101</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>sed</tag>
      
      <tag>data-processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人编程环境配置</title>
    <link href="/2022/05/13/%E4%B8%AA%E4%BA%BA%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/05/13/%E4%B8%AA%E4%BA%BA%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>必备工具：</p><ul><li><input disabled="" type="checkbox"> zsh</li><li><input disabled="" type="checkbox"> <a href="https://ohmyz.sh/#install" target="_blank" rel="noopener">oh-my-zsh</a></li><li><input disabled="" type="checkbox"> tree </li><li><input disabled="" type="checkbox"> <a href="https://www.linode.com/docs/guides/ripgrep-linux-installation/" target="_blank" rel="noopener">ripgrep</a></li><li><input disabled="" type="checkbox"> <a href="https://missing-semester-cn.github.io/2020/files/vimrc" target="_blank" rel="noopener">~/.vimrc</a></li><li><input disabled="" type="checkbox"> <a href="https://www.linuxhelp.com/how-to-install-tldr-an-alternate-to-man-pages" target="_blank" rel="noopener">tldr</a></li><li><input disabled="" type="checkbox"> <a href="https://ctrlpvim.github.io/ctrlp.vim#installation" target="_blank" rel="noopener">CtrlP</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>missing-semester-vim</title>
    <link href="/2022/05/10/missing-semester-vim/"/>
    <url>/2022/05/10/missing-semester-vim/</url>
    
    <content type="html"><![CDATA[<p><code>c</code> - correct，修改。对于修改行来说，因为<code>c2</code>后如果接表示行首的0，会导致误解，所以在输入<code>c2</code>后敲击回车即可修改从光标处开始的两整行，并进入插入模式。</p><p><code>curl -L https://missing-semester-cn.github.io/2020/files/vimrc -o ~/.vimrc</code> rc表示runtime configuration.</p><p>CtrlP是一个查看缓冲区的插件，以标签的形式切换缓冲文件是一个不太好的方法，所以CtrlP不支持。详见此<a href="https://www.reddit.com/r/vim/comments/1hkpd1/vim_how_to_jump_to_an_open_tab_using_ctrlp/" target="_blank" rel="noopener">reddit问答</a>。此thread提及，<strong>buffer</strong>是你正编辑的文件在内存中的一个表示，不能表明这个buffer和硬盘上的文件有无关联，切换标签的做法强制了每个tab使用一个buffer，会显得有点不太好。<strong>window</strong>是buffer的一个视图。tab是一组window。</p>]]></content>
    
    
    
    <tags>
      
      <tag>missing-semester</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>missing-semester-shell</title>
    <link href="/2022/05/06/missing-semester-shell/"/>
    <url>/2022/05/06/missing-semester-shell/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs shell">foo=bar #不能写成foo = bar，空格很重要echo "foo is $foo"  # 输出 foo is barecho 'foo is $foo'  # 输出 foo is $foofoo=$(pwd)# 获取当前工作目录放到foo变量内cat &lt;(ls) &lt;(ls ..) #把当前目录的文件和上级目录的文件列表拼接起来，先左后右</code></pre><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">mcd</span></span> ()&#123; <span class="hljs-comment">#mcd.sh</span>mkdir -p <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span><span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>&#125;</code></pre><p>可以通过<code>source mcd.sh</code>在shell里执行脚本，加载<code>mcd</code>函数<br>bash的特殊变量见此：<a href="https://www.tldp.org/LDP/abs/html/special-chars.html" target="_blank" rel="noopener">https://www.tldp.org/LDP/abs/html/special-chars.html</a></p><p>常用的如下</p><ul><li><code>#!</code> - shebang，指定解释器，让shell知道如何运行这个脚本</li><li><code>$0</code> - 脚本名</li><li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li><li><code>$@</code> - 所有参数</li><li><code>$#</code> - 参数个数</li><li><code>$?</code> - 前一个命令的返回值，如0为成功。</li><li><code>$$</code> - 当前脚本的进程识别码</li><li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li><li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li><li><code>$(command)</code>和``command<code></code> - 命令替换</li><li><code>$(( ))</code> - 整数运算，进制转换</li><li><code>$varible</code> - 表示变量，一般与<code>${varible}</code>相同，但是后者更精确。例如：<pre><code class="hljs shell">a=test;echo $ab #输出变量ABecho $&#123;a&#125;b #输出testb</code></pre></li></ul><p>zsh和bash真的有好多细节之处不一样，例如<code>history x</code>命令，在zsh中是显示第5条开始的所有历史记录，而bash则是倒序前5条记录。</p><p>此外，假设在文件系统中，目前有<code>a.txt</code>而没有<code>b.txt</code>，分别在zsh和bash中执行同样命令</p><pre><code class="hljs bash">ls a.txt b.txt&gt; file.out 1&gt;&amp;2cat file.out</code></pre><p>结果如下</p><table><thead><tr><th align="center">SHELL</th><th align="center">屏幕结果</th><th align="center">file.out文件内容</th></tr></thead><tbody><tr><td align="center">zsh</td><td align="center"><img src="https://s2.loli.net/2022/05/09/rNCcShdpaWiVz7o.png" srcset="/img/loading.gif" alt="zsh-屏幕输出"></td><td align="center"><img src="https://s2.loli.net/2022/05/09/MrXlizxh4YLDpbU.png" srcset="/img/loading.gif" alt="zsh-file.out"></td></tr><tr><td align="center">bash</td><td align="center"><img src="https://s2.loli.net/2022/05/09/G4AkaImjqVULPW3.png" srcset="/img/loading.gif" alt="bash-屏幕输出"></td><td align="center"><img src="C:/Users/blood/AppData/Roaming/Typora/typora-user-images/image-20220509224705892.png" srcset="/img/loading.gif" alt="bash-file.out"></td></tr></tbody></table><p>会发现在zsh中执行后，文件<code>file.out</code>中有标准输出，而bash则什么都没有。</p><p>可以发现，bash的重定向规则为：确定了每个输出流的目的地后再执行。如下所示：</p><pre><code class="hljs bash">ls a.txt b.txt 2&gt;file2.out 2&gt;&amp;1  <span class="hljs-comment"># 此处&amp;符号为取输出流1的地址，即屏幕</span><span class="hljs-comment"># 屏幕输出</span><span class="hljs-comment"># ls: cannot access b.txt: No such file or directory</span><span class="hljs-comment"># a.txt</span>cat file2.out <span class="hljs-comment"># 什么都没有</span>ls a.txt b.txt 2&gt;file2.out 2&gt;&amp;1 2&gt;file2.out<span class="hljs-comment"># 屏幕输出</span><span class="hljs-comment"># a.txt</span>cat file2.out<span class="hljs-comment"># ls: cannot access b.txt: No such file or directory</span>ls a.txt b.txt 2&gt;file2.out 2&gt;&amp;1 1&gt;file3.out <span class="hljs-comment"># 取输出流1的地址，取到屏幕的地址，所以输出流2最后输出到屏幕上</span></code></pre><p>而zsh则不然，同一个输出流可以输出到多个文件/屏幕，或者说计算到哪里就执行到哪里，如下所示。</p><pre><code class="hljs shell">ls a.txt b.txt 2&gt;file2.out 2&gt;&amp;1<span class="hljs-meta">#</span><span class="bash"> 屏幕输出</span><span class="hljs-meta">#</span><span class="bash"> a.txt</span><span class="hljs-meta">#</span><span class="bash"> ls: cannot access b.txt: No such file or directory</span>cat file2.out # ls: cannot access b.txt: No such file or directoryls a.txt b.txt 2&gt;file2.out 2&gt;&amp;1 2&gt;file3.out <span class="hljs-meta">#</span><span class="bash"> 屏幕输出</span><span class="hljs-meta">#</span><span class="bash"> a.txt</span><span class="hljs-meta">#</span><span class="bash"> ls: cannot access b.txt: No such file or directory</span>cat file2.out file3.out # 都是ls: cannot access b.txt: No such file or directoryls a.txt b.txt 2&gt;file2.out 2&gt;&amp;1 1&gt;file3.out<span class="hljs-meta">#</span><span class="bash"> 屏幕输出</span><span class="hljs-meta">#</span><span class="bash"> ls: cannot access b.txt: No such file or directory</span>cat file2.out # ls: cannot access b.txt: No such file or directorycat file3.out # a.txt</code></pre><p>先赋值一个变量为一个路径，如下：</p><pre><code class="hljs shell">file=/dir1/dir2/dir3/my.file.txt</code></pre><p>对此变量执行以下命令，</p><table><thead><tr><th align="center">命令</th><th align="center">解释</th><th>结果</th></tr></thead><tbody><tr><td align="center"><code>${file#*/}</code></td><td align="center">拿掉第一条<code>/</code> <strong>及其左边</strong>的字符串，<code>/</code>也可以是别的字符串</td><td><code>dir1/dir2/dir3/my.file.txt</code></td></tr><tr><td align="center"><code>${file##*/}</code></td><td align="center">拿掉最后一条 <code>/</code> <strong>及其左边</strong>的字符串</td><td><code>my.file.txt</code></td></tr><tr><td align="center"><code>${file%/*}</code></td><td align="center">拿掉最后一条 <code>/</code> <strong>及其右边</strong>的字符串</td><td><code>/dir1/dir2/dir3</code></td></tr><tr><td align="center"><code>${file%%/*}</code></td><td align="center">拿掉第一条 <code>/</code> <strong>及其右边</strong>的字符串</td><td>空值</td></tr><tr><td align="center"><code>${file:10:5}</code></td><td align="center">提取第 10个字节右边的连续 5 个字节</td><td><code>dir3/</code></td></tr></tbody></table><p>其余可参考<a href="https://www.cnblogs.com/chengd/p/7803664.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengd/p/7803664.html</a></p><p>下面代码中，<code>-ne</code>用来表示not equal，还有<a href="https://man7.org/linux/man-pages/man1/test.1.html" target="_blank" rel="noopener">其他比较符号</a>可供使用。zsh使用<code>[[]]</code>计算表达式。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>;<span class="hljs-keyword">do</span>    grep foobar <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> &gt; grepout 2&gt; greperr <span class="hljs-comment"># 注意，此处如果没有在文件中找到字符串，err信息为空。“没有文件”等错误才会显示err信息</span>    t=$?    <span class="hljs-keyword">if</span> [[ <span class="hljs-string">"<span class="hljs-variable">$t</span>"</span> -ne 0 ]];<span class="hljs-keyword">then</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$file</span> dont have foobar,errcode = <span class="hljs-variable">$t</span>"</span>    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span></code></pre><p>bash、zsh可以使用<code>{}</code>作为展开式，可以在一条命令里使用多个展开式，会做笛卡尔积。</p><p>在使用zsh展开式之前，可能需要<code>setopt BRACE_CCL</code>来激活，而且可能需要使用<code>{a-k}</code>而非<code>{a..k}</code>的形式。可见：<a href="https://stackoverflow.com/questions/2394728/zsh-brace-expansion-seq-for-character-lists-how" target="_blank" rel="noopener">https://stackoverflow.com/questions/2394728/zsh-brace-expansion-seq-for-character-lists-how</a></p><pre><code class="hljs shell">convert img.&#123;png,jpg&#125; # 等于convert img.png img.jpgtouch foo&#123;,1&#125; # 等于 touch foo,foo1touch foo&#123;a..c&#125; # 等于 touch fooa foob foocdiff &lt;(ls dir1) &lt;(ls dir2) # 比较目录的不同</code></pre><p>可以用<code>shellcheck</code>命令检查shell脚本</p><p>在 <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html" target="_blank" rel="noopener"><code>env</code></a> 命令，会利用环境变量中的程序来解析该脚本，提高了脚本的可移植性。<code>env</code> 会利用<code>PATH</code> 环境变量来进行定位。 使用了<code>env</code>的shebang可以如此：<code>#!/usr/bin/env python</code></p><p>shell函数和脚本有如下一些不同点：</p><ul><li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="httsp://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查找所有名称为src的文件夹，d是目录，f是文件</span>find . -name src -type d<span class="hljs-meta">#</span><span class="bash"> 查找所有文件夹路径中包含<span class="hljs-built_in">test</span>的python文件</span>find . -path '*/test/*.py' -type f #也可以找出当前目录下的，因为*包括了.（即当前目录），因查找内容中包含/，所以要用path或者wholename作为flag<span class="hljs-meta">#</span><span class="bash"> 查找前一天修改的文件</span>find . -mtime -1<span class="hljs-meta">#</span><span class="bash"> 前60分钟修改的文件</span>find . -mmin 60<span class="hljs-meta">#</span><span class="bash"> 查找所有大小在500k至10M的tar.gz文件</span>find . -size +500k -size -10M -name '*.tar.gz'<span class="hljs-meta">#</span><span class="bash"> 删除全部扩展名为.tmp 的文件</span>find . -name '*.tmp' -exec rm &#123;&#125; \; #考虑到不同系统的分号意义不同，所以最后加上了\<span class="hljs-meta">#</span><span class="bash"> 查找全部的 PNG 文件并将其转换为 JPG</span>find . -name '*.png' -exec convert &#123;&#125; &#123;&#125;.jpg \;</code></pre><p><a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode，而且其语法更符合直觉。</p><p>locate命令：和find类似，但是建立索引、使用索引，会更快，使用前需要使用<code>updatedb</code>更新，一般每日会自动更新。</p><p>tldr: 简洁版的man</p><p><code>grep</code> 有很多选项，例如有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p><p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p><p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/" target="_blank" rel="noopener">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="noopener">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在当前目录递归查找</span>grep -R foobar .<span class="hljs-meta">#</span><span class="bash"> 查找所有使用了 requests 库的文件</span>rg -t py 'import requests'<span class="hljs-meta">#</span><span class="bash"> 查找所有没有写 shebang 的文件（包含隐藏文件），-u表示dont ignore hidden files</span>rg -u --files-without-match "^#!"<span class="hljs-meta">#</span><span class="bash"> 查找所有的foo字符串，并打印其之后的5行</span>rg foo -A 5<span class="hljs-meta">#</span><span class="bash"> 打印匹配的统计信息（匹配的行和文件的数量）</span>rg --stats PATTERN</code></pre><p>alias: 别名</p><p>注意：<code>zsh</code>的<code>man</code>手册和<code>bash</code>的<code>man</code>手册有所区别，例如<code>history 1</code>在<code>zsh</code>中为从第一行开始的历史记录，而在<code>bash</code>中返回最近的一条记录。</p><p>同一命令在不同shell里面的表现形式可能不同，例如上述的history，是shell builtin命令，因此不同shell例如zsh和bash的实现就不同。</p><p>可以使用<code>type</code>区分一条命令是shell builtin还是用户命令。</p><p>可参考<a href="https://tinylab.org/shell-builtin-command/" target="_blank" rel="noopener">Shell 的内置（builtin）命令是什么，常常傻傻分不清</a>一文</p><p>使用<code>man zshbuiltins</code>查看zsh内置shell命令。</p><p>参照<a href="https://stackoverflow.com/questions/4405382/how-can-i-read-documentation-about-built-in-zsh-commands" target="_blank" rel="noopener">此文</a>设置<code>.zshrc</code>文件，完成后<code>source</code>加载。可在<code>oh my zsh</code>环境下使用，输入命令后使用<code>alt+h</code>即可查询。或者使用<code>help command</code>在zsh的手册中查询。和<code>man</code>一样，可以使用<code>/text</code>查询<code>text</code>文本在手册中的位置，找到后分别使用<code>n</code>和<code>N</code>定位下一个和上一个。</p><pre><code class="hljs sh"><span class="hljs-built_in">unalias</span> run-help 2&gt;/dev/null<span class="hljs-built_in">autoload</span> run-helpHELPDIR=/path/to/zsh_help_directory <span class="hljs-comment"># /usr/local/share/zsh/help on OSX 暂未尝试</span><span class="hljs-comment"># /usr/share/zsh/5.0.2/functions/run-help on CentOS 7 可用</span><span class="hljs-built_in">alias</span> <span class="hljs-built_in">help</span>=run-help</code></pre><p><code>Ctrl+R</code>可在交互式shell里查询历史命令。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search" target="_blank" rel="noopener">zsh</a> 中，使用方向键上或下也可以完成这项工作。<code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r" target="_blank" rel="noopener">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p><p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p><p><code>tar</code>压缩命令，找到所有html文件并且压缩成zip。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 建立数据</span>mkdir html_rootcd html_roottouch &#123;1..10&#125;.htmlmkdir htmlcd htmltouch xxxx.htmlcd ../..<span class="hljs-meta">#</span><span class="bash"><span class="hljs-keyword">for</span> MacOS</span>find html_root -name "*.html" -print0 | xargs -0 tar vcf html.zip<span class="hljs-meta">#</span><span class="bash"><span class="hljs-keyword">for</span> Linux</span>find . -type f -name "*.html" | xargs -d '\n'  tar -cvzf html.zip #c表示create新文件，z表示支持gzip，f表示压缩完后文件的名字一般必填，v表示显示指令执行过程。f指令必须在最后，用于指定压缩文件名。</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> bash</span>foo=bar # 定义shell变量fooexport foo # 导出shell变量foo到环境变量unset $foo # 删除shell变量bar，因为$foo的值是barunset foo # 删除shell变量fooexport -n # 删除环境变量foo，如果是函数，flag就为-fn<span class="hljs-meta">#</span><span class="bash"> zsh</span>unset foo # 会把shell变量foo和环境变量foo都删除</code></pre><h2 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h2><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录 间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html" target="_blank" rel="noopener">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd" target="_blank" rel="noopener"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump" target="_blank" rel="noopener">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm" target="_blank" rel="noopener"><em>frecency</em> </a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener"><code>tree</code></a>, <a href="https://github.com/Canop/broot" target="_blank" rel="noopener"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn" target="_blank" rel="noopener"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger" target="_blank" rel="noopener"><code>ranger</code></a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>missing-semester</tag>
      
      <tag>bash</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang channel</title>
    <link href="/2021/08/03/Golang-channel/"/>
    <url>/2021/08/03/Golang-channel/</url>
    
    <content type="html"><![CDATA[<p>Go的无缓冲<code>channel</code>的发送/接收操作会阻塞直到被接收/发送。如果是在goroutinue里面，怎么阻塞都不要紧，以为main结束了goroutine也就结束了。但如果在main里面阻塞就会报panic(fatal error: all goroutines are asleep - dead lock!)</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"sync"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;wg := sync.WaitGroup&#123;&#125;times := <span class="hljs-number">10</span>wg.Add(times)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; times; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(i) <span class="hljs-comment">// i指向循环段的变量，需要用临时变量代替才不会出错，这样写会有问题，打印出来的大部分数字都是times，而且是随机的。</span>wg.Done()&#125;()&#125;wg.Wait()fmt.Println(<span class="hljs-string">"all done"</span>)&#125;</code></pre><p>channel和WaitGroup都可以用来完成并发的工作，channel更注重于通信，wg不通信。</p><pre><code class="hljs go">sig := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)signal.Notify(sig,syscall.SIGINT,syscall.SIGTERM) <span class="hljs-comment">// 可以用来作等待，等待ctrl-c终止信号，不加后面的值就监测所有信号。</span></code></pre><pre><code class="hljs go"><span class="hljs-keyword">chan</span> T          <span class="hljs-comment">// 可以接收和发送类型为 T 的数据</span><span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">float64</span>  <span class="hljs-comment">// 只可以用来发送 float64 类型的数据</span>&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>      <span class="hljs-comment">// 只可以用来接收 int 类型的数据</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Go</tag>
      
      <tag>信号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang slice</title>
    <link href="/2021/08/03/Golang-slice/"/>
    <url>/2021/08/03/Golang-slice/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs go">x := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)x[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;x[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;x[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>y:=x[<span class="hljs-number">1</span>:];y[<span class="hljs-number">0</span>]=<span class="hljs-number">99</span>fmt.Println(x,y) <span class="hljs-comment">// [1,99,3] [99,3]</span>fmt.Println(<span class="hljs-built_in">len</span>(y),<span class="hljs-built_in">cap</span>(y)) <span class="hljs-comment">// 2 2 </span>fmt.Println(<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x)) <span class="hljs-comment">// 3 3</span>y = <span class="hljs-built_in">append</span>(y, <span class="hljs-number">1</span>) <span class="hljs-comment">// 容量不够，所以分配了一块新内存，把原有的值挪上去</span>y[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>fmt.Println(x,y) <span class="hljs-comment">// [1 99 3] [-1 3 1]</span><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">int</span>slice2:=<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">0</span>)slice3:= []<span class="hljs-keyword">int</span>&#123;&#125; <span class="hljs-comment">// 分配了内存</span>fmt.Println(slice1,slice2,slice3) <span class="hljs-comment">// [] [] []</span>fmt.Println(<span class="hljs-built_in">len</span>(slice1),<span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 0 0</span>fmt.Println(<span class="hljs-built_in">len</span>(slice2),<span class="hljs-built_in">cap</span>(slice2)) <span class="hljs-comment">// 0 0</span>fmt.Println(<span class="hljs-built_in">len</span>(slice3),<span class="hljs-built_in">cap</span>(slice3)) <span class="hljs-comment">// 0 0</span>fmt.Println(reflect.DeepEqual(slice1,slice2)) <span class="hljs-comment">// false</span>fmt.Println(reflect.DeepEqual(slice1,slice3)) <span class="hljs-comment">// false</span>fmt.Println(reflect.DeepEqual(slice2,slice3)) <span class="hljs-comment">// true</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis相关总结</title>
    <link href="/2021/04/23/redis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/23/redis%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>推荐书籍《redis设计与实现》</p><h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><h2 id="简单动态字符串-SDS"><a href="#简单动态字符串-SDS" class="headerlink" title="简单动态字符串 (SDS)"></a>简单动态字符串 (SDS)</h2><h3 id="内容物"><a href="#内容物" class="headerlink" title="内容物"></a>内容物</h3><ol><li><p>len: 已用字节数量，保存的字符串长度</p><ul><li>不包括\0，好处是可以重用一部分C库函数；</li><li>获取长度仅需O(1)时间复杂度。</li><li>杜绝缓冲区溢出</li></ul></li><li><p>free: 未用字节的数量</p><ul><li><p>和C字符串相比，减少修改字符串的内存重分配次数</p><ul><li><p>空间预分配</p><ol><li>如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。</li><li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。</li></ol></li><li><p>惰性空间释放</p><p>比如sdstrim之后没有释放多出来的空间，而是放入free中，需要的时候可以显式释放。</p></li></ul></li></ul></li><li><p>buf: 字<strong>节</strong>数组。</p></li></ol><p><img src="https://i.loli.net/2021/04/25/X6ziVAC1HeNjd3P.png" srcset="/img/loading.gif" alt="image-20210425203945371"></p><ul><li><p>二进制安全</p><p>保存的时候是什么样子，读取的时候就是什么样子。可以写入空字符。都是用二进制方式来处理数据的。使用len判断是否结束而不是’\0’。</p></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="内容物-1"><a href="#内容物-1" class="headerlink" title="内容物"></a>内容物</h3><p>node内有：前节点，后节点，值。</p><p>list内有：表头、表尾节点，节点值复制、释放、对比函数。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>双端，无环，有头尾，有长度，多态（用void*指针来保存值）。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="内容物-2"><a href="#内容物-2" class="headerlink" title="内容物"></a>内容物</h3><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span>    <span class="hljs-comment">// 哈希表数组</span>    dictEntry **table;    <span class="hljs-comment">// 哈希表大小</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-built_in">size</span>;    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span>    <span class="hljs-comment">// 总是等于size-1</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;    <span class="hljs-comment">// 该哈希表已有节点的数量</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;&#125; dictht;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span>    <span class="hljs-comment">// 类型特定函数</span>    dictType *type;    <span class="hljs-comment">// 私有数据</span>    <span class="hljs-keyword">void</span> *privdata;    <span class="hljs-comment">// 哈希表</span>    dictht ht[<span class="hljs-number">2</span>];    <span class="hljs-comment">// rehash索引</span>    <span class="hljs-comment">// 当rehash不在进行时，值为-1</span>    in trehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span>&#125; dict;</code></pre><p>用拉链法解决冲突。拉成单链表，没有尾指针，新节点加在链表头部。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>目的是维持负载因子在合理范围内。步骤如下：</p><ol><li>分配空间，收缩分配第一个大于ht[0].used的2<sup>n</sup>，扩展分配第一个大于ht[0].used<strong>*2</strong>的2<sup>n</sup></li><li>把ht[0]的键值对全部重新计算位置，放到ht[1]上面。</li><li>释放ht[0]，ht[1]变成ht[0]，ht[1]创建空白表。</li></ol><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</p><p>2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p><p>3）在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时（都先在ht[0]上，查不到再去ht[1]），程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</p><p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为<strong>-1</strong>，表示rehash操作已完成。</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>作用：快速访问节点，平均O（logN）、最坏O（N）复杂度的查找。实现简单。</p><h3 id="内容物-3"><a href="#内容物-3" class="headerlink" title="内容物"></a>内容物</h3><ul><li><p>header：指向跳跃表的表头节点。</p></li><li><p>tail：指向跳跃表的表尾节点。</p></li><li><p>level：记录目前跳跃表内，<strong>层数最大</strong>的那个节点的层数（表头节点的层数不计算在内）。</p></li><li><p>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</p></li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span>    <span class="hljs-comment">// 层</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span>        <span class="hljs-comment">// 前进指针，用于访问位于表尾方向的其他节点</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span>        <span class="hljs-comment">// 跨度，记录了前进指针所指向节点和当前节点的距离</span>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> span;    &#125; level[];    <span class="hljs-comment">// 后退指针，指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span>    <span class="hljs-comment">// 分值，在表内从小到大排列。</span>    <span class="hljs-keyword">double</span> score;    <span class="hljs-comment">// 成员对象，指向一个SDS对象，分值相同的按照这个从小到大再排序，要求每个值都不同。</span>    robj *obj;&#125; zskiplistNode;</code></pre><p>创建节点的时候，根据幂次定律随机生成1-32的值作为level数组的大小。</p><h2 id="压缩链表"><a href="#压缩链表" class="headerlink" title="压缩链表"></a>压缩链表</h2><p>顺序型数据结构。每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p><p><img src="https://i.loli.net/2021/04/25/WYsTn6CmLucepGw.png" srcset="/img/loading.gif" alt="image-20210425213941481"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>终端中按下ctrl+c之后发生了什么</title>
    <link href="/2021/04/22/%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%8C%89%E4%B8%8Bctrl-c%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2021/04/22/%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%8C%89%E4%B8%8Bctrl-c%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>在终端内按下ctrl+c之后，键盘输入产生硬件中断。</p><p>如果系统还在执行代码，那么用户空间内代码暂停执行。切换到内核态处理硬件中断。</p><p>把ctrl+c解释成为SIGINT信号，记录在进程控制块中（<em>PCB</em> Process Control Block）。</p><p>当从内核态返回用户态的时候，处理PCB中的信号，发现SIGINT信号需要处理，这个信号的默认处理动作是终止进程，所以终止进程。</p><p>相关阅读：<a href="https://www.runoob.com/cplusplus/cpp-signal-handling.html" target="_blank" rel="noopener">C++ 信号处理 | 菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B+树理解</title>
    <link href="/2021/04/21/B-%E6%A0%91%E7%90%86%E8%A7%A3/"/>
    <url>/2021/04/21/B-%E6%A0%91%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>数据结构可视化网站：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html" target="_blank" rel="noopener">B+ Tree Visualization (usfca.edu)</a></p><p>对于MySQL而言，B+树节点大小为<code>1页=16K</code>，因为对于大部分业务，16K足够。通常1-3层B+树就足以应对常见场景。</p><p>为什么足够：</p><ol><li>B+树的叶子节点存的是数据行，非叶子节点是key+指针</li><li><ul><li>叶子节点：如果一行数据大小是1K，那么能存16个数据</li><li>非叶子节点：如果key用的是bigint，那么8字节，MySQL中指针是6字节，那么需要<code>8+6=14</code>字节，一页16K能存放<code>16*1024/14=1170</code>个key+指针。根节点有1170个key+指针，下一层有<code>1170*1170</code>个key+指针，最底层有<code>1170*1170*16=21902400</code>个数据，达到两千万级别了。</li></ul></li></ol><p>近似满的度为3的高为3的B+树。（0000和0001处没满）</p><p><img src="https://i.loli.net/2021/04/26/3ploMSnuBc4YKD2.png" srcset="/img/loading.gif" alt="满B+树"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL联合索引</title>
    <link href="/2021/04/19/MySQL%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/04/19/MySQL%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<ol><li>有顺序：(A,B,C)和(A,C,B)不一样。</li><li>建立(A,B,C)后相当于建立A,AB,ABC三个索引。</li><li>注意：索引列不要参与计算。尽量把筛选效率高的列放在左边。AC只能命中A的索引。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式研读-2</title>
    <link href="/2021/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/"/>
    <url>/2021/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/</url>
    
    <content type="html"><![CDATA[<p>推荐书籍：《研磨设计模式》</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>例子：旧硬盘可以直接和电源线相连，而新硬盘需要转接线才能。这就是适配器。数据库第一版和第二版接口不一致，需要用适配器。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h2 id="应用适配器模式来解决问题的思路"><a href="#应用适配器模式来解决问题的思路" class="headerlink" title="应用适配器模式来解决问题的思路"></a>应用适配器模式来解决问题的思路</h2><p>问题的根源在于第一版和第二版接口的不兼容，功能是基本实现了的，也就是说，只要想办法让两边的接口匹配起来，就可以复用第一版的功能了。</p><p>按照适配器模式的实现方式，可以定义一个类来实现第二版的接口，然后在内部实现的时候，转调第一版已经实现了的功能，这样就可以通过对象组合的方式，既复用了第一版已有的功能，同时又在接口上满足了第二版调用的要求。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>复用性好，扩展性好。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>过多使用容易混乱。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>例子：读配置文件只需要创建一个实例就可以到处使用。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>需要的时候（getInstance的时候发现没有）再创建。加锁可以实现线程安全。加锁可以分为在整个函数上面加锁和二重检查加锁。时间换空间。</p><p><img src="https://i.loli.net/2021/04/25/TgSJ4w2qMAGDVPt.png" srcset="/img/loading.gif" alt="image-20210425194953297"></p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>用static实现，类装载的时候就初始化。Python的话因为没有静态变量，所以可以用装饰器实现。空间换时间。</p><blockquote><pre><code class="hljs python">&gt;<span class="hljs-comment"># Python实现static</span>&gt;@static_vars(counter = <span class="hljs-number">0</span>)&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>   foo.counter += <span class="hljs-number">1</span></code></pre></blockquote><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>单例-&gt;2例，3例。</p><p>用Map控制缓存。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式研读-1</title>
    <link href="/2021/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"/>
    <url>/2021/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/</url>
    
    <content type="html"><![CDATA[<p>推荐书籍：《研磨设计模式》</p><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><ol><li>简单工厂创建物体的时候，需要客户端选择传入参数，说明客户端必须直到每个参数的意义，理解每个参数对应的功能。<strong>这要求一定程度上</strong>向客户端暴露内部实现。</li><li>每次给工厂增加一个实现类都需要修改工厂类的实现：Java/Python/Golang 的话可以通过配置文件修改，引入反射解决这个问题。也可以使用<strong>IoC/DI（控制反转/依赖注入）</strong>实现。</li><li>本质是<strong>选择</strong>实现。实现是具体的类做的，而不是简单工厂做的。能和其他创建具体对象实例的模式配合使用，如单例，原型。生成器模式。</li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>实现封装，解耦。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="增加客户端复杂度"><a href="#增加客户端复杂度" class="headerlink" title="增加客户端复杂度"></a>增加客户端复杂度</h3><p>客户端需要理解参数意义。</p><h3 id="不方便扩展子工厂"><a href="#不方便扩展子工厂" class="headerlink" title="不方便扩展子工厂"></a>不方便扩展子工厂</h3><p>简单工厂的构造方法是静态的。不过通常不需要构造子简单工厂。</p><h1 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h1><p>比如代码生成工具，需要表现层，逻辑层，数据层。那么如果不用模式来实现，会需要单独创建这三个层，创建三次。而外观模式这样操作：打包这三者，客户端直接调用打包好的类创建即可。相当于这三个模块的外观界面，不需要知道模块内部实现细节，甚至不需要知道这三者的存在（比如卖电脑，打包成电脑之后客户端不需要知道有没有独显）。只需要和Facade类交互即可，解耦了客户端和这三个模块。</p><ol><li>外观模式目的是外部减少和子系统内模块交互，降低耦合。不是添加新的接口。目的是组合已有功能来实现客户端需要，不是添加新功能。</li><li>部分开发者不需要了解内部各个模块细节了。</li><li>也可以跳过外观模式直接用模块。只是多了一个选项。</li><li>外观类可以是单例。</li></ol><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>解耦，不需要和子系统交互，只需要和外观交互。实现分层。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>过多/不合理的外观模式让人不知道是用它还是直接用模块。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统知识点总结</title>
    <link href="/2021/04/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/04/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="进程的内存布局中，哪些是线程共享的"><a href="#进程的内存布局中，哪些是线程共享的" class="headerlink" title="进程的内存布局中，哪些是线程共享的"></a>进程的内存布局中，哪些是线程共享的</h1><h1 id="什么是缓存溢出"><a href="#什么是缓存溢出" class="headerlink" title="什么是缓存溢出"></a>什么是缓存溢出</h1><p>程序在申请内存时，没有足够的内存空间供其使用。</p><h1 id="一定要有线程吗？"><a href="#一定要有线程吗？" class="headerlink" title="一定要有线程吗？"></a>一定要有线程吗？</h1><p>可以没有，但是线程可以解决并发，切换开销过大的问题。</p><h1 id="进程与线程的切换开销？"><a href="#进程与线程的切换开销？" class="headerlink" title="进程与线程的切换开销？"></a>进程与线程的切换开销？</h1><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><ol><li><p>切换页表全局目录</p></li><li><p>切换内核态堆栈</p></li><li><p>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</p><ul><li><p>ip(instruction pointer)：指向当前执行指令的下一条指令</p></li><li><p>bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址</p></li><li><p>sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址</p></li><li><p>cr3:页目录基址寄存器，保存页目录表的物理地址</p></li><li><p>……</p></li></ul></li><li><p>刷新TLB</p></li><li><p>系统调度器的代码执行</p></li></ol><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>共享同一内存地址空间、代码段、全局变量、同一打开文件集合。</p><ol><li>切换内核栈</li><li>切换硬件上下文</li></ol><h1 id="单cpu能够实现多任务并行吗"><a href="#单cpu能够实现多任务并行吗" class="headerlink" title="单cpu能够实现多任务并行吗"></a>单cpu能够实现多任务并行吗</h1><p>不能，只能并发</p><h1 id="堆和栈的区别（空间分配、缓存方式）"><a href="#堆和栈的区别（空间分配、缓存方式）" class="headerlink" title="堆和栈的区别（空间分配、缓存方式）"></a>堆和栈的区别（空间分配、缓存方式）</h1><h1 id="ipc中效率最高的是哪种方式"><a href="#ipc中效率最高的是哪种方式" class="headerlink" title="ipc中效率最高的是哪种方式"></a>ipc中效率最高的是哪种方式</h1><p>共享内存允许多个进程直接对同一个内存区域直接操作。</p><h1 id="说说虚拟内存，为什么要这么设计，解决了什么问题"><a href="#说说虚拟内存，为什么要这么设计，解决了什么问题" class="headerlink" title="说说虚拟内存，为什么要这么设计，解决了什么问题"></a>说说虚拟内存，为什么要这么设计，解决了什么问题</h1><ul><li>虚拟内存给进程提供了一个更大的内存空间，只在主存里保留活动区域</li><li>给每个进程提供了一致的、完整的地址空间。</li><li>为程序提供内存管理，内存隔离。</li></ul><h1 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h1><p>分段：粒度大</p><p>分页：粒度小</p><h1 id="中断是如何实现的"><a href="#中断是如何实现的" class="headerlink" title="中断是如何实现的"></a>中断是如何实现的</h1><p>中断是一种电信号，由硬件设备产生，并直接送入中断控制器（如8259A）的输入引脚上，然后再由中断控制器向处理器发送相应的信号。 处理器一经检测到该信号，便中断自己当前正在处理的工作，转而去处理中断。</p><h1 id="哪三种情况会导致用户态到内核态的切换？"><a href="#哪三种情况会导致用户态到内核态的切换？" class="headerlink" title="哪三种情况会导致用户态到内核态的切换？"></a>哪三种情况会导致用户态到内核态的切换？</h1><ul><li>系统调用。</li><li>异常。</li><li>中断。</li></ul><h1 id="死锁和活锁"><a href="#死锁和活锁" class="headerlink" title="死锁和活锁"></a>死锁和活锁</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol><li>互斥</li><li>持有并等待</li><li>非抢占</li><li>循环等待</li></ol><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>提供锁的全序/偏序（部分序列）。</p><p><img src="https://i.loli.net/2021/04/15/BjDMVGIp4CuQPql.png" srcset="/img/loading.gif" alt="非抢占"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="什么场景适合用悲观锁，什么场景适合用乐观锁"><a href="#什么场景适合用悲观锁，什么场景适合用乐观锁" class="headerlink" title="什么场景适合用悲观锁，什么场景适合用乐观锁"></a>什么场景适合用悲观锁，什么场景适合用乐观锁</h1><p>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。 … 像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库知识点总结</title>
    <link href="/2021/04/13/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/04/13/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="select-为什么会很慢"><a href="#select-为什么会很慢" class="headerlink" title="select * 为什么会很慢"></a>select * 为什么会很慢</h1><p>网络传输，CPU cost，IO cost。</p><p>如果select * 与你想查询的字段完全一致，单单就查询来说，select * 并没有降低查询效率。但时实际使用中这种情况极少。获取了不必要的列，此时要走全表扫描，会变慢。</p><p>影响自动优化，*的话就不优化。</p><h1 id="MySQL的默认引擎是什么"><a href="#MySQL的默认引擎是什么" class="headerlink" title="MySQL的默认引擎是什么"></a>MySQL的默认引擎是什么</h1><p>MySQL5.5以前是MyISAM，之后默认的事务引擎是InnoDB。</p><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>事务</td><td>不支持</td><td><font color=red>支持</font></td></tr><tr><td>行级锁</td><td>不支持</td><td><font color=red>支持</font></td></tr><tr><td>锁的最小粒度</td><td>表级锁</td><td><font color=red>行级锁</font></td></tr><tr><td>外键</td><td>不支持</td><td><font color=red>支持</font></td></tr><tr><td>全文索引</td><td><font color=red>支持</font></td><td>不支持FULLTEXT，但有插件可以支持</td></tr><tr><td>崩溃后安全恢复</td><td>不能</td><td><font color=red>能</font></td></tr><tr><td>适合情况</td><td><font color=red>读</font>密集</td><td><font color=red>写</font>密集</td></tr><tr><td>复杂度</td><td><font color=red>简单</font></td><td>复杂</td></tr></tbody></table><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code></p><h1 id="索引的优缺点，什么场景适用"><a href="#索引的优缺点，什么场景适用" class="headerlink" title="索引的优缺点，什么场景适用"></a>索引的优缺点，什么场景适用</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>加快检索速度</p></li><li><p>加速表表连接</p></li><li><p>加快order by, group by</p></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>创建维护需要时间</li><li>数据量少的时候得不偿失</li><li>索引占据物理空间，聚簇索引空间更大</li><li>增删改的时候也要维护索引，数据维护速度变慢</li></ol><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><h3 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h3><blockquote><p>CREATE INDEX column_index ON table (column);</p></blockquote><h3 id="间接创建"><a href="#间接创建" class="headerlink" title="间接创建"></a>间接创建</h3><blockquote><p>定义主键约束或者唯一性键约束</p></blockquote><h2 id="普通索引和唯一性索引"><a href="#普通索引和唯一性索引" class="headerlink" title="普通索引和唯一性索引"></a>普通索引和唯一性索引</h2><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><blockquote><p>CREATE INDEX column_index ON table (column);</p></blockquote><h3 id="唯一性索引"><a href="#唯一性索引" class="headerlink" title="唯一性索引"></a>唯一性索引</h3><p>保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用</p><blockquote><p>CREATE UNIQUE COUSTERED INDEX column_index ON table(column)</p></blockquote><h2 id="单个索引和复合索引"><a href="#单个索引和复合索引" class="headerlink" title="单个索引和复合索引"></a>单个索引和复合索引</h2><h3 id="单个索引"><a href="#单个索引" class="headerlink" title="单个索引"></a>单个索引</h3><p>即非复合索引</p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>又叫组合索引，在索引建立语句中同时包含多个字段名，最多<strong>16</strong>个字段</p><blockquote><p>CREATE INDEX name_index ON username(first_name,last_name)</p></blockquote><h2 id="聚簇索引和非聚簇索引-聚集索引，群集索引"><a href="#聚簇索引和非聚簇索引-聚集索引，群集索引" class="headerlink" title="聚簇索引和非聚簇索引(聚集索引，群集索引)"></a>聚簇索引和非聚簇索引(聚集索引，群集索引)</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列</p><blockquote><p>CREATE CLUSTERED INDEX my_column_cindex ON table(column) WITH ALLOW_DUP_ROW;(允许有重复记录的聚簇索引)</p></blockquote><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><blockquote><p>CREATE UNCLUSTERED INDEX my_column_cindex ON table(column);</p></blockquote><h1 id="什么时候索引会失效"><a href="#什么时候索引会失效" class="headerlink" title="什么时候索引会失效"></a>什么时候索引会失效</h1><ol><li><p>%匹配在前</p></li><li><p>使用!=,&lt;&gt;,not null,is null</p></li><li><p>运算，如substring,+,-</p></li><li><p>字符串不加单引号</p></li><li><p>从取范围的列的后一个关键字开始失效</p></li><li><p>用or会失效，用union和in替换则不会：</p><blockquote><p>select loc_id , loc_desc , region from location where loc_id = 10<br>union<br>select loc_id , loc_desc , region  from location where region = “melbourne”;</p><p>或</p><p>select… from location where loc_in  in (10,20,30);</p><p>取代</p><p>select loc_id , loc desc , region from location where loc_id = 10 or region = “melbourne”;</p></blockquote></li><li><p>复合索引跳过了中间的列，中间索引右边的索引<strong>全部失效</strong>，左边的索引生效。</p></li></ol><h1 id="数据库除了使用索引，想优化查找效率还能怎么做"><a href="#数据库除了使用索引，想优化查找效率还能怎么做" class="headerlink" title="数据库除了使用索引，想优化查找效率还能怎么做"></a>数据库除了使用索引，想优化查找效率还能怎么做</h1><ol><li>优化表结构，根据范式/反范式设计。<ul><li>使用可存下数据的最小的数据类型</li><li>使用简单的数据类型，int要比varchar类型在MySQL处理上更简单</li><li>尽量用not null</li><li>少用text，非用不可最好分表（水平，垂直分表），将text字段存放到另一张表中，<strong>在需要的时候再使用联合查询</strong>，这样可提高查询主表的效率。</li></ul></li><li>硬件优化</li><li>通过慢查询日志发现有效率问题的SQL</li></ol><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><ol><li><p>选择索引</p><ul><li><p>选择合适的索引列，选择在where，group by，order by，on从句中出现的列作为索引项，对于离散度不大的列没有必要创建索引。</p></li><li><p>索引字段越小越好(因为数据库的存储单位是页，一页中能存下的数据越多越好 )</p></li><li><p>离散度越大的列放在联合索引越前面</p><blockquote><p>select count(distinct ziduan1),count(distinct ziduan2) from table_name;<br>越大越离散</p></blockquote></li></ul></li><li><p>索引优化</p><ul><li>联合索引不要加上主键,InnoDB已经默认加了。</li><li>不是越多越好</li></ul></li></ol><h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><p>每个列的属性不能再分</p><h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><p>消除了非主属性对码的<strong>部分</strong>函数依赖</p><h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><p>消除了非主属性对码的<strong>传递</strong>函数依赖</p><h1 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h1><p>ACID，AID服务于C</p><h1 id="详细说说一致性"><a href="#详细说说一致性" class="headerlink" title="详细说说一致性"></a>详细说说一致性</h1><ul><li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li><li><a href="https://zh.wikipedia.org/wiki/可用性" target="_blank" rel="noopener">可用性</a>（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li><a href="https://zh.wikipedia.org/w/index.php?title=网络分区&action=edit&redlink=1" target="_blank" rel="noopener">分区容错性</a>（<strong>P</strong>artition tolerance）</li></ul><p>三者只能得其二。</p><h1 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h1><p>乐观锁：只在更新的时候检查数据完整性。可以使用版本号来实现。</p><p>悲观锁：屏蔽一切可能违反数据完整性的操作。</p><p>行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>间隙锁：</p><p>防止幻读。</p><h1 id="主键索引和聚簇索引"><a href="#主键索引和聚簇索引" class="headerlink" title="主键索引和聚簇索引"></a>主键索引和聚簇索引</h1><p>一个表只能有一个聚簇索引</p><p>sale 部门 ：3字段 部门名字 员工ID 销售额度</p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>统计每个部门销售额度</p><blockquote><p>select 部门，sum(销售额) from table group by 部门</p></blockquote><p>统计每个部门销售额度&gt;10W的</p><blockquote><p>select 部门，sum(销售额) from table group by 部门 having sum(*)&gt;10W</p></blockquote><h1 id="为什么用B-树作为结构"><a href="#为什么用B-树作为结构" class="headerlink" title="为什么用B+树作为结构"></a>为什么用B+树作为结构</h1><ul><li>哈希虽然能够提供 <code>O(1)</code> 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；</li><li>B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；</li></ul><h1 id="乐观-悲观锁"><a href="#乐观-悲观锁" class="headerlink" title="乐观/悲观锁"></a>乐观/悲观锁</h1><ul><li>乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都<strong>没有对数据库进行加锁</strong>；</li><li>悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；</li></ul><p>乐观锁不会存在死锁的问题，但是由于更新后验证，所以当<strong>冲突频率</strong>和<strong>重试成本</strong>较高时更推荐使用悲观锁，而需要非常高的<strong>响应速度</strong>并且<strong>并发量</strong>非常大的时候使用乐观锁就能较好的解决问题，在这时使用悲观锁就可能出现严重的性能问题；在选择并发控制机制时，需要综合考虑上面的四个方面（冲突频率、重试成本、响应速度和并发量）进行选择。</p><h1 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h1><p><strong>意向锁不会与行级的共享 / 排他锁互斥！！！</strong>意向锁和意向锁之间不互斥。</p><p><a href="https://juejin.cn/post/6844903666332368909" target="_blank" rel="noopener">https://juejin.cn/post/6844903666332368909</a></p><p>获取一个行的X锁之后，会对整个表加一个意向排他锁，不让另一个事务对表加X/S锁。目的就是不用一行行检查了。</p><p>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>参考：<a href="https://www.cnblogs.com/wy123/p/8365234.html" target="_blank" rel="noopener">https://www.cnblogs.com/wy123/p/8365234.html</a></p><h2 id="Error-log"><a href="#Error-log" class="headerlink" title="Error log"></a>Error log</h2><p>错误日志文件对MySQL的启动、运行、关闭过程进行了记录。MySQL DBA在遇到问题时应该首先查看该文件以便定位问题。该文件不仅记录了所有的<strong>错误信息</strong>，也记录一些<strong>警告信息</strong>或<strong>正确的信息</strong>。用于<strong>数据库优化</strong>。</p><h2 id="Redolog"><a href="#Redolog" class="headerlink" title="Redolog"></a>Redolog</h2><h2 id="slow-log：慢查询日志"><a href="#slow-log：慢查询日志" class="headerlink" title="slow log：慢查询日志"></a>slow log：慢查询日志</h2><p>可以在MySQL启动时设一个阈值，将运行时间大于（不等于）该值的所有SQL语句都记录到慢查询日志文件中。用于<strong>SQL语句优化</strong>。</p><h2 id="log：查询日志"><a href="#log：查询日志" class="headerlink" title="log：查询日志"></a>log：查询日志</h2><p>记录了所有对MySQL数据库请求的信息，<strong>无论</strong>这些请求是否得到了正确的执行。</p><h2 id="Undolog"><a href="#Undolog" class="headerlink" title="Undolog"></a>Undolog</h2><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>不包括select,show等操作。记录UPDATE等操作（哪怕操作本身没有成功）</p><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p><img src="https://i.loli.net/2021/07/12/OoK84PEFXI7wQbp.png" srcset="/img/loading.gif" alt="image-20210329140506273"></p><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p>应该先更新数据库再删除缓存。更新数据库之后可以让缓存失效。</p><p>如果先删除缓存再更新数据库：</p><ul><li>事务B删除缓存</li><li>事务A查询缓存，没有缓存，从数据库找到旧值</li><li>此时事务B更新数据库</li><li>事务A把旧值写到缓存，造成后面的数据有问题</li></ul><p>那么，是不是一开始这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p><p>但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p><h1 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h1><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p><p>HAVING 子句可以让我们筛选分组后的各组数据。</p><h1 id="JOIN-子句"><a href="#JOIN-子句" class="headerlink" title="JOIN 子句"></a>JOIN 子句</h1><p>首先，连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。</p><p>左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。</p><p>外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段。</p><p>这部分主要涉及的是表连接的逻辑问题，教程主讲语法的话这部分确实需要自己再去搜资料</p><blockquote><p>来源：《数据库系统原理教程》，王珊，陈红编著，P86</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识点总结</title>
    <link href="/2021/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="路由器和交换机位于哪一层"><a href="#路由器和交换机位于哪一层" class="headerlink" title="路由器和交换机位于哪一层"></a>路由器和交换机位于哪一层</h1><p>路由器：网络层</p><p>交换机：数据链路层</p><h1 id="滑动窗口的实现机制"><a href="#滑动窗口的实现机制" class="headerlink" title="滑动窗口的实现机制"></a>滑动窗口的实现机制</h1><h2 id="发送方的四种数据"><a href="#发送方的四种数据" class="headerlink" title="发送方的四种数据"></a>发送方的四种数据</h2><ol><li>Sent and Acknowledged：这些数据表示已经发送成功并已经被确认的数据，比如图中的前31个bytes，这些数据其实的位置是在窗口之外了，因为窗口内顺序最低的被确认之后，要移除窗口，实际上是窗口进行合拢，同时打开接收新的带发送的数据</li><li>Send But Not Yet Acknowledged：这部分数据称为发送但没有被确认，数据被发送出去，没有收到接收端的ACK，认为并没有完成发送，这个属于窗口内的数据。</li><li>Not Sent，Recipient Ready to Receive：这部分是尽快发送的数据，这部分数据已经被加载到缓存中，也就是窗口中了，等待发送，其实这个窗口是完全有接收方告知的，接收方告知还是能够接受这些包，所以发送方需要尽快的发送这些包</li><li>Not Sent，Recipient Not Ready to Receive： 这些数据属于未发送，同时接收端也不允许发送的，因为这些数据已经超出了接受端所接收的范围</li></ol><h2 id="接收方的三种数据"><a href="#接收方的三种数据" class="headerlink" title="接收方的三种数据"></a>接收方的三种数据</h2><ol><li>Received and ACK Not Send to Process：这部分数据属于接收了数据，已经回复了。但是还没有被上层的应用程序接收，也是被缓存在窗口内</li><li>Received  Not ACK: 已经接收并，但是还没有回复ACK，这些包可能输属于Delay ACK的范畴了</li><li>Not Received：有空位，还没有被接收的数据。</li></ol><h1 id="IP和TCP传输的都是些什么数据"><a href="#IP和TCP传输的都是些什么数据" class="headerlink" title="IP和TCP传输的都是些什么数据"></a>IP和TCP传输的都是些什么数据</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="头部分"><a href="#头部分" class="headerlink" title="头部分"></a>头部分</h3><p>IP版本，长度，服务类型，源/目的IP地址。偏移，校验和，TTL。</p><h3 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h3><p>TCP包</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="头部分-1"><a href="#头部分-1" class="headerlink" title="头部分"></a>头部分</h3><p>源/目的端口号，序号，确认号，6个标志位，校验和。</p><h3 id="数据部分-1"><a href="#数据部分-1" class="headerlink" title="数据部分"></a>数据部分</h3><p>应用层数据。</p><h1 id="如何将一个长URL转换为一个短URL"><a href="#如何将一个长URL转换为一个短URL" class="headerlink" title="如何将一个长URL转换为一个短URL"></a>如何将一个长URL转换为一个短URL</h1><ol><li>HashMap 短地址长地址一一对应（最烂）</li><li>短转长，但不存在逆运算（比较烂）</li><li>hash后如果碰撞，后面加123；或者碰撞后多次hash（一般烂）</li><li><strong><font color=red>使用发号策略，长地址发号一个短地址</font></strong>。（最好）<ul><li>使用MySQL的自增索引。比如0-9,a-z,A-Z实现62位进制的自增。保存可以用十进制，需要的时候转62位即可。</li><li>高并发可用：n个发号器，每个发号器每次增长n而不是1。</li><li>长查短：保存最近生成的一些对应关系，一定时间或者一定数量后开始淘汰。</li><li>跳转可以用301或者302。301可以减少服务器压力，302的话可以统计次数，原因见下。</li></ul></li></ol><h1 id="分析一个URL各个字段的含义"><a href="#分析一个URL各个字段的含义" class="headerlink" title="分析一个URL各个字段的含义"></a>分析一个URL各个字段的含义</h1><p>协议://IP:端口/具体地址</p><h1 id="如果没有http2-0-如何解决短连接问题"><a href="#如果没有http2-0-如何解决短连接问题" class="headerlink" title="如果没有http2.0 如何解决短连接问题"></a>如果没有http2.0 如何解决短连接问题</h1><h1 id="http状态码301和302的具体区别"><a href="#http状态码301和302的具体区别" class="headerlink" title="http状态码301和302的具体区别"></a>http状态码301和302的具体区别</h1><p>在搜索引擎角度，301的话，前后两个网址的PageRank是不一样的，新网址需要重新累加PageRank。302的话前后网址视作和前面一样的同一个。排名也是。</p><p>对客户端来说，301的话，会永久记住新网址，如果加到书签，下次访问就是新的了。而302的话每次都得重新请求。</p><p>HTTP到HTTPS必须用301。</p><h1 id="抓包工具的原理"><a href="#抓包工具的原理" class="headerlink" title="抓包工具的原理"></a>抓包工具的原理</h1><p><strong>抓包工具会在网络传输的某个层次或节点截获收发的数据</strong></p><p>如http代理，chrome的network。</p><h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><p><img src="https://i.loli.net/2021/07/12/6hDB8sTzJjKNi2V.png" srcset="/img/loading.gif" alt=""></p><h1 id="http2-0针对http1-1的优化有哪些"><a href="#http2-0针对http1-1的优化有哪些" class="headerlink" title="http2.0针对http1.1的优化有哪些"></a>http2.0针对http1.1的优化有哪些</h1><table><thead><tr><th></th><th>HTTP/2</th><th>HTTP1.1</th></tr></thead><tbody><tr><td><strong>传输协议</strong></td><td><font color=red>二进制</font></td><td>文本</td></tr><tr><td><strong>头部信息</strong></td><td><font color=red>压缩</font></td><td>未压缩的文本</td></tr><tr><td><strong>各字段长度</strong></td><td><font color=red>固定</font></td><td>不固定</td></tr><tr><td><strong>多路复用</strong></td><td><font color=red>是</font></td><td>否</td></tr><tr><td><strong>连接与请求的关系</strong></td><td>单个连接可以发送<font color=red>多个请求和响应</font></td><td>只能一个</td></tr><tr><td><strong>服务器推送</strong></td><td><font color=red>支持</font></td><td>否</td></tr></tbody></table><h1 id="http1-1的性能瓶颈"><a href="#http1-1的性能瓶颈" class="headerlink" title="http1.1的性能瓶颈"></a>http1.1的性能瓶颈</h1><ul><li><p>只能逐个顺序响应请求报文，前一个响应未完成就只能一直阻塞等待而无法传输下一个响应报文，这就白白浪费了TCP 连接的带宽资源，同时带来了队头阻塞问题。</p></li><li><p>重复传输臃肿的首部字段，降低了网络资源利用率。</p></li><li><p>各字段长度不固定，解析不容易。</p></li><li><p>只能客户端发起请求。</p></li></ul><h1 id="http1-1相比于http1-0的优化"><a href="#http1-1相比于http1-0的优化" class="headerlink" title="http1.1相比于http1.0的优化"></a>http1.1相比于http1.0的优化</h1><ul><li><strong>持久连接</strong></li><li>请求管道化，即流水线化，可以不用等待回复就发请求。</li><li>增加缓存处理（新的字段如cache-control）</li><li>增加Host字段、支持断点传输等</li></ul><h1 id="对称加密和非对称加密的区别，对称加密是如何保证安全性的"><a href="#对称加密和非对称加密的区别，对称加密是如何保证安全性的" class="headerlink" title="对称加密和非对称加密的区别，对称加密是如何保证安全性的"></a>对称加密和非对称加密的区别，对称加密是如何保证安全性的</h1><h1 id="http1-1新增了哪几种请求方法"><a href="#http1-1新增了哪几种请求方法" class="headerlink" title="http1.1新增了哪几种请求方法"></a>http1.1新增了哪几种请求方法</h1><p>OPTIONS、PUT、PATCH、DELETE、TRACE 和CONNECT 方法</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。<font color=red>是幂等的方法</font></td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。<font color=red>不是幂等的方法</font></td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。<font color=red>是幂等的方法</font></td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h1 id="http有哪些常见的请求方法-创建一篇文章用什么请求方法"><a href="#http有哪些常见的请求方法-创建一篇文章用什么请求方法" class="headerlink" title="http有哪些常见的请求方法 创建一篇文章用什么请求方法"></a>http有哪些常见的请求方法 创建一篇文章用什么请求方法</h1><p>应该用POST，因为文章创建了不能再创建，应该是非幂等的。</p><h1 id="tcp怎么判断丢包"><a href="#tcp怎么判断丢包" class="headerlink" title="tcp怎么判断丢包"></a>tcp怎么判断丢包</h1><p>超时，或者接到对一个seq的包的连续3个ACK。</p><h1 id="http协议中的cookie和session是什么"><a href="#http协议中的cookie和session是什么" class="headerlink" title="http协议中的cookie和session是什么"></a>http协议中的cookie和session是什么</h1><p>参考：<a href="http://www.ityouknow.com/it/2019/05/11/cookie-session.html" target="_blank" rel="noopener">http://www.ityouknow.com/it/2019/05/11/cookie-session.html</a></p><p>参考：<a href="https://segmentfault.com/a/1190000017831088" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017831088</a></p><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li></ul><p><strong>不要混淆 session 和 session 实现。</strong></p><p>本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。</p><p> 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。</p><p>而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。</p><p>所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。</p><h1 id="ping实现的原理"><a href="#ping实现的原理" class="headerlink" title="ping实现的原理"></a>ping实现的原理</h1><p>发送ICMP报文</p><h1 id="什么是ICMP"><a href="#什么是ICMP" class="headerlink" title="什么是ICMP"></a>什么是ICMP</h1><p>ICMP协议的功能主要有：</p><ol><li>确认IP包是否成功到达目标地址</li><li>通知在发送过程中IP包被丢弃的原因</li></ol><p>tracert和ping命令用ICMP</p><h1 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h1><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数到30</title>
    <link href="/2021/04/13/%E6%95%B0%E5%88%B030/"/>
    <url>/2021/04/13/%E6%95%B0%E5%88%B030/</url>
    
    <content type="html"><![CDATA[<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>从1开始，每个人可以报1-3个数字，先后手自定，找最佳策略。</p><h2 id="谁先数到30算赢"><a href="#谁先数到30算赢" class="headerlink" title="谁先数到30算赢"></a>谁先数到30算赢</h2><p>先手必胜：先手A先报2个数，后面A每次和B凑成4个，就必胜。</p><h2 id="谁先数到30算输"><a href="#谁先数到30算输" class="headerlink" title="谁先数到30算输"></a>谁先数到30算输</h2><p>先手的人尽力凑到29。所以先报1，然后A每次和B凑4个，就必胜。</p>]]></content>
    
    
    
    <tags>
      
      <tag>智力题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2021/04/10/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2021/04/10/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/wxquare/p/4759020.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxquare/p/4759020.html</a></p><p><a href="http://c.biancheng.net/view/7898.html" target="_blank" rel="noopener">http://c.biancheng.net/view/7898.html</a></p><h1 id="什么是智能指针"><a href="#什么是智能指针" class="headerlink" title="什么是智能指针"></a>什么是智能指针</h1><p>智能指针是指向动态分配的内存区（堆）里的对象。</p><h1 id="智能指针有什么用"><a href="#智能指针有什么用" class="headerlink" title="智能指针有什么用"></a>智能指针有什么用</h1><p>用于生存期控制，确保正确销毁动态分配的对象。防止内存泄漏。</p><p>理解智能指针需要从下面三个层次：</p><ol><li>从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把值语义转换成引用语义。C++和Java有一处最大的区别在于语义不同，在Java里面下列代码：<pre><code class="hljs Java">Animal a = <span class="hljs-keyword">new</span> Animal();Animal b = a;</code></pre>你当然知道，这里其实只生成了一个对象，a和b仅仅是把持对象的引用而已。但在C++中不是这样，<pre><code class="hljs Java">Animal a;Animal b = a;</code></pre><h1 id="智能指针里面有什么，怎么设计实现的"><a href="#智能指针里面有什么，怎么设计实现的" class="headerlink" title="智能指针里面有什么，怎么设计实现的"></a>智能指针里面有什么，怎么设计实现的</h1></li></ol><p>利用自动调用的类的析构函数来释放内存。从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</p><ol><li>引用计数。</li></ol><h1 id="各个智能指针的异同"><a href="#各个智能指针的异同" class="headerlink" title="各个智能指针的异同"></a>各个智能指针的异同</h1><h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><del>auto_ptr</del></h2><p>已经在C++11里弃用，C++11开始起用如下3个智能指针。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>引用计数，指向相同内存。每析构一次，引用减一，直到为0，删除指向的堆内存。线程安全，读取需要加锁。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><p>不能将指针直接赋值给一个智能指针。</p></li><li><p>避免循环引用。</p></li><li><p>不要用原始指针初始化多个<code>shared_ptr</code>。否则会多次释放同一块内存。</p></li></ul><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    &#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptra = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(a);        <span class="hljs-comment">//std::shared_ptr&lt;int&gt; ptra1 = std::make_shared&lt;int&gt;(a);//不要初始化多个，会出错。</span>        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptra2</span><span class="hljs-params">(ptra)</span></span>; <span class="hljs-comment">//copy</span>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;        <span class="hljs-keyword">int</span> *pb = &amp;a;        <span class="hljs-comment">//std::shared_ptr&lt;int&gt; ptrb = pb;  //error</span>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; ptrb = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(b);        ptra2 = ptrb; <span class="hljs-comment">//assign</span>        pb = ptrb.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">//获取原始指针</span>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>和shared_ptr不一样，不能拷贝。只能移动。同一时间只能有一个unique_ptr指向一个对象。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    &#123;        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>))</span></span>;  <span class="hljs-comment">//绑定动态对象</span>        <span class="hljs-comment">//std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能賦值</span>        <span class="hljs-comment">//std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷貝</span>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; uptr2 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(uptr); <span class="hljs-comment">//轉換所有權</span>        uptr2.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//释放所有权</span>    &#125;    <span class="hljs-comment">//超過uptr的作用域，內存釋放</span>&#125;</code></pre><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator<em>和-&gt;,*</em>它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况<strong>。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，</strong>它的构造不会引起指针引用计数的增加**。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p><p>使用的时候要检查是否为空。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p1;             <span class="hljs-comment">//不传入任何实参</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;    <span class="hljs-comment">//传入空指针 nullptr</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>))</span></span>;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p3 = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用拷贝构造函数</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p4</span><span class="hljs-params">(p3)</span></span>;<span class="hljs-comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span><span class="hljs-comment">//调用移动构造函数，因为move是非原子性的，比拷贝这个原子性的操作更快</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p4))</span></span>; <span class="hljs-comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></code></pre><h1 id="智能指针带来了什么问题"><a href="#智能指针带来了什么问题" class="headerlink" title="智能指针带来了什么问题"></a><del>智能指针带来了什么问题</del></h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><del>问题</del></h2><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><del>解决方案</del></h2>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编译过程</title>
    <link href="/2021/04/08/C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/04/08/C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://www.runoob.com/w3cnote/working-process-of-the-compiler.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/working-process-of-the-compiler.html</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>编译器工作前，需要知道系统环境：</p><ol><li>标准库的位置</li><li>软件的安装位置</li><li>安装的组件<br>……<br>配置保存在configure的脚本文件里，通常用autoconf生成。</li></ol><h1 id="确定标准库、头文件的位置"><a href="#确定标准库、头文件的位置" class="headerlink" title="确定标准库、头文件的位置"></a>确定标准库、头文件的位置</h1><p>配置文件给出一个清单，列出具体目录，编译的时候依次寻找。</p><h1 id="确定依赖关系"><a href="#确定依赖关系" class="headerlink" title="确定依赖关系"></a>确定依赖关系</h1><p>编译器确定编译的先后顺序，如果A依赖于B，那么编译器会：<br>（1）只有在B文件编译完成后，才开始编译A文件。<br>（2）当B文件发生变化时，A文件会被重新编译。<br>编译顺序保存在一个叫做<strong>makefile</strong>的文件中，里面列出哪个文件先编译，哪个文件后编译。而<strong>makefile</strong>文件由<strong>configure</strong>脚本运行生成，这就是为什么编译时<strong>configure</strong>必须首先运行的原因。</p><p>在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。</p><h1 id="头文件预编译"><a href="#头文件预编译" class="headerlink" title="头文件预编译"></a>头文件预编译</h1><p>不同源码编译的时候可能会用同一个头文件，预先编译头文件会节省后面的时间，保证只编译一次。</p><p>但不是头文件的所有内容都会被编译，#define等声明宏的命令不会被预编译。</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>编译器开始替换源码中的头文件和宏。移除注释。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, FILE *)</span></span>;<span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fputs</span>(<span class="hljs-string">"Hello, world!\n"</span>, <span class="hljs-built_in">stdout</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>此步之后得到 .i 文件</p><h1 id="编译，生成目标代码"><a href="#编译，生成目标代码" class="headerlink" title="编译，生成目标代码"></a>编译，生成目标代码</h1><p>开始生成机器码，对于某些编译器还会转成汇编码(.s文件)，再转成机器码。</p><p>汇编器把.s文件转成.o文件。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>把库文件，启动文件，其他目标文件链接到.o文件上。生成可执行文件。此为静态链接，即<strong>编译期间链接</strong>。Windows下是.lib，Linux下是.a文件。</p><p>优点：装载快，执行快，不需要考虑用户是否存在正确的.lib文件。缺点：可执行文件大，可能包含相同代码，造成浪费，可扩展性低。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>在运行的时候才进行链接，Windows下是.dll，Linux下是.so文件。</p><p>优点：可执行文件小，扩展性好，适合大规模开发，可维护性好，更换动态链接文件不需要换exe文件。缺点：装载略慢，执行略慢，需要考虑用户是否存在正确的.lib文件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ const</title>
    <link href="/2021/04/07/C-const/"/>
    <url>/2021/04/07/C-const/</url>
    
    <content type="html"><![CDATA[<h1 id="const-修饰指针指向的内容"><a href="#const-修饰指针指向的内容" class="headerlink" title="const 修饰指针指向的内容"></a>const 修饰指针指向的内容</h1><p>内容不可以改变。如下。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">4</span>;    <span class="hljs-keyword">int</span> b=<span class="hljs-number">5</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p=&amp;a;    p=&amp;b;<span class="hljs-comment">//OK</span>    *p=<span class="hljs-number">9</span>;<span class="hljs-comment">//error</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h1><p>那么指针本身不可以改变。指针指向的值可以改变。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">4</span>;<span class="hljs-keyword">int</span> b=<span class="hljs-number">5</span>;    <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p=&amp;a;    *p=<span class="hljs-number">9</span>;<span class="hljs-comment">//ok</span>p=&amp;b;<span class="hljs-comment">//error</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="可以同时修饰指针和指针指向的值。"><a href="#可以同时修饰指针和指针指向的值。" class="headerlink" title="可以同时修饰指针和指针指向的值。"></a>可以同时修饰指针和指针指向的值。</h1><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span>  p = &amp;a;</code></pre><p>函数传参的时候，参数如果是<code>const int a</code>，那么a在函数内不能改变。也可以使用上述3种情况的代码。</p><h1 id="对于自定义类型"><a href="#对于自定义类型" class="headerlink" title="对于自定义类型"></a>对于自定义类型</h1><p>传参数可以加 const &amp;，比如<code>const Test &amp; test1</code>，<code>Test</code>是类型名，<code>test1</code>是变量名。这样不用拷贝，可以加速参数传递。</p><h1 id="修饰函数返回值"><a href="#修饰函数返回值" class="headerlink" title="修饰函数返回值"></a>修饰函数返回值</h1><p>一般组合 const int &amp;使用。如果只有&amp;没有const，说明是引用，即别名，是左值可以被赋值，防止修改的话需要加const。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> data;<span class="hljs-keyword">public</span>:    A(<span class="hljs-keyword">int</span> num):data(num)&#123;&#125;    ~A()&#123;&#125;;    <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">get_data</span><span class="hljs-params">()</span><span class="hljs-comment">//返回引用</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> data;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    a.get_data()=<span class="hljs-number">3</span>;<span class="hljs-comment">//加了const 就error</span>    <span class="hljs-built_in">cout</span>&lt;&lt;a.get_data()&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如果const单纯修饰int等内置类型，那么修不修饰没区别。</p><p>如果函数返回值是个指针，那么也和前面说的前三个一样。但要注意赋值前后值的类型应该一致。如下：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//这要求指针不能改，但是指针指的值可以改。</span><span class="hljs-keyword">int</span> * p;p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;*p = <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p1= f1();<span class="hljs-comment">//通过，但不能是const int * p1，因为这样修饰了p1对应的值，而不是指针本身。</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>const</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多态</title>
    <link href="/2021/04/07/C-%E5%A4%9A%E6%80%81/"/>
    <url>/2021/04/07/C-%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>类之间存在层次结构，且类之间通过继承关联的时候就会用到多态。</p><p>多态意味着调用成员函数的时候，会通过成员类型来决定调用什么函数。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span>   <span class="hljs-keyword">protected</span>:      <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>;   <span class="hljs-keyword">public</span>:      Shape( <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>)      &#123;         <span class="hljs-built_in">width</span> = a;         <span class="hljs-built_in">height</span> = b;      &#125;      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span><span class="hljs-function">      </span>&#123;         <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Parent class area :"</span> &lt;&lt;<span class="hljs-built_in">endl</span>;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span> <span class="hljs-keyword">public</span> Shape&#123;   <span class="hljs-keyword">public</span>:      Rectangle( <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>):Shape(a, b) &#123; &#125;      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><span class="hljs-function">      </span>&#123;          <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Rectangle class area :"</span> &lt;&lt;<span class="hljs-built_in">endl</span>;         <span class="hljs-keyword">return</span> (<span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span>);       &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span>:</span> <span class="hljs-keyword">public</span> Shape&#123;   <span class="hljs-keyword">public</span>:      Triangle( <span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>):Shape(a, b) &#123; &#125;      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><span class="hljs-function">      </span>&#123;          <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Triangle class area :"</span> &lt;&lt;<span class="hljs-built_in">endl</span>;         <span class="hljs-keyword">return</span> (<span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span> / <span class="hljs-number">2</span>);       &#125;&#125;;<span class="hljs-comment">// 程序的主函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><span class="hljs-function"></span>&#123;   Shape *shape;   <span class="hljs-function">Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">7</span>)</span></span>;   <span class="hljs-function">Triangle  <span class="hljs-title">tri</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)</span></span>;    <span class="hljs-comment">// 存储矩形的地址</span>   shape = &amp;rec;   <span class="hljs-comment">// 调用矩形的求面积函数 area</span>   shape-&gt;area();    <span class="hljs-comment">// 存储三角形的地址</span>   shape = &amp;tri;   <span class="hljs-comment">// 调用三角形的求面积函数 area</span>   shape-&gt;area();      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>调用函数 area() 被编译器设置为<strong>基类中的版本</strong>，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p><p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>，就输出对应的子类了。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p><p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p><p>可以被继承后重写。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <link href="/2021/04/06/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2021/04/06/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>题源 <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</a></p><pre><code class="hljs python">Class RandomNode:    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,x:int,next:<span class="hljs-string">'RandomNode'</span>=None,random:<span class="hljs-string">'RandomNode'</span>=None)</span>:</span>        self.val=x        self.next=next        self.random=random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head:<span class="hljs-string">'RandomNode'</span>)</span>:</span>    visited=&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root:<span class="hljs-string">'RandomNode'</span>)</span>:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> root       <span class="hljs-keyword">nonlocal</span> visited        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">in</span> visited:            <span class="hljs-keyword">return</span> visited[root]        copy=RandomNode(root.val)        visited[root]=copy        copy.next=dfs(root.next)        copy.random=dfs(root.random)        <span class="hljs-keyword">return</span> copy   <span class="hljs-keyword">return</span> dfs(head)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2021/04/06/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/04/06/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>进程是运行中的一段程序。包括程序的可执行代码和程序计数器，调用堆栈等。</p><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p><p><img src="https://i.loli.net/2021/04/06/KVLDB4MafjIxpGW.png" srcset="/img/loading.gif" alt="进程"></p><h1 id="进程-线程切换开销"><a href="#进程-线程切换开销" class="headerlink" title="进程/线程切换开销"></a>进程/线程切换开销</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li>页表全局目录；</li><li>调用堆栈和堆栈；</li><li>文件描述符；</li><li>处理器硬件上下文，比如栈帧的指针，寄存器内容，高速缓存；</li><li>TLB的刷新，即建立新的映射。</li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>局部的程序计数器，程序指针，局部的栈帧，相关寄存器状态（线程的上下文）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引用和指针的区别</title>
    <link href="/2021/04/06/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/04/06/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>引用是别名。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>引用被创建的时候必须<strong>立刻初始化</strong>；</li><li><strong>不能有NULL引用</strong>；</li><li>被初始化后就<strong>不能改变</strong>引用关系。对n的操作就是对m的操作。不是拷贝，不是指针，n就是m。</li></ol><pre><code class="hljs c++"><span class="hljs-keyword">int</span> m; <span class="hljs-keyword">int</span> &amp;n = m;</code></pre><h1 id="值传递-指针传递-引用传递-的异同"><a href="#值传递-指针传递-引用传递-的异同" class="headerlink" title="值传递/指针传递/引用传递 的异同"></a>值传递/指针传递/引用传递 的异同</h1><p>由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span><span class="hljs-function"></span>&#123;     x = x + <span class="hljs-number">10</span>; &#125; <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; Func1(n); <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"n = "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// n = 0</span></code></pre><p>以下是”指针传递”的示例程序。</p><p>由于 Func2 函数体内的 x 是指向外部变量 n 的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span> </span><span class="hljs-function"></span>&#123;     (* x) = (* x) + <span class="hljs-number">10</span>; &#125; <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; Func2(&amp;n);<span class="hljs-comment">// 取指针</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"n = "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// n = 10</span></code></pre><p>以下是”引用传递”的示例程序。</p><p>由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span> </span><span class="hljs-function"></span>&#123;     x = x + <span class="hljs-number">10</span>; &#125; <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; Func3(n); <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"n = "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// n = 10</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ static</title>
    <link href="/2021/04/06/C-static/"/>
    <url>/2021/04/06/C-static/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是static，用来干什么的，解决什么问题"><a href="#什么是static，用来干什么的，解决什么问题" class="headerlink" title="什么是static，用来干什么的，解决什么问题"></a>什么是static，用来干什么的，解决什么问题</h1><p>c/c++的<strong>修饰符</strong>，控制变量的存储方式和可见性。函数内部定义的变量，执行到的时候为它在栈上分配空间，函数结束后释放，如果要保留这个值到下次调用的时候，就需要加static。如果用全局变量，会破坏变量访问范围。</p><h2 id="如何控制存储方式"><a href="#如何控制存储方式" class="headerlink" title="如何控制存储方式"></a>如何控制存储方式</h2><p><img src="https://i.loli.net/2021/04/06/z6a8MjCXl3UVfgK.png" srcset="/img/loading.gif" alt="全局静态存储区"></p><p>全局（静态）存储区：分为DATA和BSS（Block started by symbol）段，DATA段存放初始化的全局变量和静态变量，BSS段存放未初始化的全局变量。</p><p>静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以<strong>静态数据成员不能在任何函数内分配空间和初始化。</strong>所以，也不能在类内初始化为一个值，必须在类外初始化。</p><h2 id="如何分配空间"><a href="#如何分配空间" class="headerlink" title="如何分配空间"></a>如何分配空间</h2><p>在类的外部接口的头文件，或者main函数之前。<code>int Point::m_nPointCount;</code>这样就可以。</p><h1 id="static可以用在哪，以及作用"><a href="#static可以用在哪，以及作用" class="headerlink" title="static可以用在哪，以及作用"></a>static可以用在哪，以及作用</h1><ol><li><p>修饰局部变量</p><p>只初始化一次，延长生命周期。</p></li><li><p>修饰全局变量<br>限定只能本文件内访问。</p></li><li><p>修饰函数<br>限定只能本文件内访问。</p></li></ol><h1 id="全局变量和全局静态变量的区别"><a href="#全局变量和全局静态变量的区别" class="headerlink" title="全局变量和全局静态变量的区别"></a>全局变量和全局静态变量的区别</h1><p>不显式用static修饰的变量作用域是整个工程，可以被外部文件用extern访问。</p><h1 id="如何使用static变量和static方法"><a href="#如何使用static变量和static方法" class="headerlink" title="如何使用static变量和static方法"></a>如何使用static变量和static方法</h1><p>通过<code>类名.变量/方法</code>来访问，不需要new一个类。或者<code>类名::静态成员名</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户态和内核态</title>
    <link href="/2021/04/05/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"/>
    <url>/2021/04/05/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="用户态和内核态是什么"><a href="#用户态和内核态是什么" class="headerlink" title="用户态和内核态是什么"></a>用户态和内核态是什么</h1><h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><p>CPU只能受限的访问内存，不能访问外围设备。占用CPU的能力低，能被抢占。Ring3</p><h2 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h2><p>CPU可以访问内存的所有数据。Ring0</p><h1 id="为什么要有内核态和用户态"><a href="#为什么要有内核态和用户态" class="headerlink" title="为什么要有内核态和用户态"></a>为什么要有内核态和用户态</h1><p>需要限制不同应用程序的访问能力。</p><h1 id="为什么要切换"><a href="#为什么要切换" class="headerlink" title="为什么要切换"></a>为什么要切换</h1><p>用户程序一般都运行在用户态。但是从硬盘读取数据，键盘输入等时候，用户态不能完成，需要请求操作系统内核，让操作系统内核替自己去执行。所以用户程序不能控制操作系统内核<strong>具体执行的指令</strong>。</p><h1 id="如何切换到内核态"><a href="#如何切换到内核态" class="headerlink" title="如何切换到内核态"></a>如何切换到内核态</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>用户程序主动发起的。</p><p>流程：</p><ol><li>用户态程序把数据放到寄存器中，或者用参数创建一个堆栈，告诉操作系统需要服务。</li><li>用户态程序执行陷阱指令。</li><li>CPU切换到内核态，进入内核地址空间，跳到指定指令。这些指令被保护，不能被用户态程序访问。</li><li>读取指令并执行。</li><li>返回用户态。</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>用户程序被动接收的。比如缺页异常。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>用户程序被动接收的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树/二叉搜索树的最近公共祖先</title>
    <link href="/2021/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-comment"># class TreeNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.left = None</span><span class="hljs-comment">#         self.right = None</span></code></pre><p>若 root 是 p, q 的 最近公共祖先 ，则只可能为以下情况之一：</p><ol><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p=root ，且 q 在 root 的左或右子树中；</li><li>q=root ，且 p 在 root 的左或右子树中；</li></ol><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(self, root: <span class="hljs-string">'TreeNode'</span>, p: <span class="hljs-string">'TreeNode'</span>, q: <span class="hljs-string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span>    <span class="hljs-comment"># 二叉树，</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:        <span class="hljs-keyword">return</span> root    <span class="hljs-keyword">if</span> root==q <span class="hljs-keyword">or</span> root==p:        <span class="hljs-keyword">return</span> root    l=lowestCommonAncestor(root.left,p,q)    r=lowestCommonAncestor(root.right,p,q)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> l:        <span class="hljs-keyword">return</span> r    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> r:        <span class="hljs-keyword">return</span> l    <span class="hljs-keyword">return</span> root</code></pre><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(self, root: <span class="hljs-string">'TreeNode'</span>, p: <span class="hljs-string">'TreeNode'</span>, q: <span class="hljs-string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span>    <span class="hljs-comment"># 二叉搜索树</span>    <span class="hljs-keyword">if</span> p.val&lt;root.val <span class="hljs-keyword">and</span> q.val&lt;root.val:        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left,p,q)    <span class="hljs-keyword">elif</span> p.val&gt;root.val <span class="hljs-keyword">and</span> q.val&gt;root.val:        <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right,p,q)    <span class="hljs-comment">#只在(p.val-root.val)*(q.val-root.val)&lt;0 即两者异号的时候返回root，同号归边。</span>    <span class="hljs-keyword">return</span> root</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Session &amp; Cookie</title>
    <link href="/2021/04/05/Session-Cookie/"/>
    <url>/2021/04/05/Session-Cookie/</url>
    
    <content type="html"><![CDATA[<p>Session：用来存放用户数据，浏览器<strong>第一次</strong>发送请求的时候，服务器生成了Session和Session ID来唯一标识这个Session。<strong>第二次</strong>发送请求的时候带上Session ID，就能对应上。</p><p>Session的实现方法：</p><ol><li>使用Cookie。如果不设置过期时间，就不放在硬盘上，浏览器关闭就消失。如果设置为几天后过期，那么就会在硬盘上保存。</li><li>使用URL附加信息。比如<code>?JSESSIONID=</code>不设置过期时间，浏览器关闭就过期。</li></ol><p>Session放在服务端，Cookie放在客户端。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2020/10/26/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/10/26/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/10/26/XGY9vBA5tDTRyuk.png" srcset="/img/loading.gif" alt="JAVA字符流.png"></p><p><strong>接口可以有default、static方法</strong></p><p>原先的jdk7之类的，它们接口中的方法都是抽象方法，没有具体的实现，就相当于定义好了这个接口有哪些功能，却没有具体定义功能是怎么实现的，通常由接口的实现类来做具体功能实现。那么，如果面向接口编程，大家已经根据自己需要通过继承接口的方式来实现了自己的功能，突然有一天，产品提需求了，你需要给所有接口的实现类都添加一个新的功能即一个新的方法实现，而且这个方法可能大家都是一样的，那咋办？</p><p>jdk8以前的做法肯定是现在接口中定义这个抽象方法，然后所有实现类必须实现这个方法（不然接口中多出一个抽象方法，其他类都没有实现，编译是会报错的），如果实现类比较多，那改起来会很麻烦，这种情况下是不利于维护的。</p><p>那么我们在jdk8中就有了好的解决方式，就是在接口中加一个默认方法，这个默认方法有具体实现，这样就不用去修改实现类啦，很省事。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary</title>
    <link href="/2020/10/10/Diary/"/>
    <url>/2020/10/10/Diary/</url>
    
    <content type="html"><![CDATA[<p>好多梗原来是出自星爷的电影啊。<br>“有钱人的品味有时候很奇怪”，出自喜剧之王;<br>“喊好好味，喊到我满意为止”，可能出自食神。<br>切水果游戏的原型可能也出自食神内唐牛表演的刀工。<br>你这次有麻烦了，方丈为人很小气的。我最讨厌别人在我的背后说我坏话。<br>得罪了方丈，你想走？没那么容易！<br>来人，喂两位公子吃饼–九品芝麻官<br>我玩完了她，不给钱，那就不算卖咯<br>你叫破了喉咙也没有人理你的<br>我跳出来了，我又跳回去了<br>你好大的官威啊，包大人<br>我顶你个肺<br>你拿明朝的剑来斩清朝的官<br>我一进门就看到常威在打来福<br>审死官:<br>不要把我的衣服弄皱了，和美人鱼里的联动</p><p>国产凌凌漆：<br>你以为躲起来就找不到你？没有用的，像你这样的男人，不管在什么地方，就好像漆黑中的萤火虫一样那样的鲜明，那样的出众。你那忧郁的眼神，唏嘘的胡渣，神乎其技的刀法，还有那杯dry Martine，都深深地迷住了我。</p><p><img src="https://i.loli.net/2021/07/12/KvizYd9oycPOpmH.png" srcset="/img/loading.gif" alt="image-20201205084905972"></p><p>我希望你叫我全名：达文西。小漆：没问题，文西。文西：多谢。小漆：不客气，文西。</p><p>猪猡公园，侏罗纪公园哈哈哈哈</p><p>最近发明的太阳能电筒，有电的时候会亮，没电的时候绝对不会亮。拿另外一只手电筒照他的时候，就会亮了。</p><p>要你命三千。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>notes</title>
    <link href="/2020/10/08/notes/"/>
    <url>/2020/10/08/notes/</url>
    
    <content type="html"><![CDATA[<h1 id="网际层协议"><a href="#网际层协议" class="headerlink" title="网际层协议"></a>网际层协议</h1><p>IP: Internet Protocol<br>  提供网络结点之间的报文传送服务</p><p>A类网络：网络号占1个字节，但只有7位可以使用（因为第一位固定为0）。但可指派的网络号是126个。IP 0.0.0.0表示本网络。网络号127保留作为本地软件环回测试本主机的进程之间的通信之用。每一个A类网络中最大主机数量是2^24-2，全1（255）的主机号字段表示该网络上所有主机。全0表示本主机所在的网络地址。</p><p>B类网络：网络号占2个字节，前两位是10。但B类网络128.0.0.0是不指派。B类可指派的网络数量为2^14-1，可指派的最小值是128.1.0.0（因为网络号有2位）。每个网络的主机数为2^16-2=65534（去掉全0和全1，即255.255）。</p><p>C类网络：网络号占3个字节，110开头。同样不指派192.0.0.0。可指派的最小值是192.0.1.0（因为网络号有3位）。可指派的网络书是2^21-1。每个网络主机数是254。</p><p>一个网络是指具有相同网络号的主机的集合。</p><table><thead><tr><th>网络类别</th><th>第一个网络段的开头位（二进制位）</th><th>最大可指派的网络数</th><th>每个网络最大主机数量</th><th>第一个可指派的网络</th><th>最后一个可指派的网络</th><th>不指派的网络</th></tr></thead><tbody><tr><td>A类网络</td><td>0</td><td>2<sup>8-1</sup>-2</td><td>2<sup>21</sup>-2</td><td>1</td><td>126</td><td>0（保留地址，本网络）和127（环回地址，供本地软件测试）</td></tr><tr><td>B类网络</td><td>10</td><td>2<sup>16-2</sup>-1=16383</td><td>2<sup>16</sup>-2=65534</td><td>128.1</td><td>191.255</td><td>128.0</td></tr><tr><td>C类网络</td><td>110</td><td>2<sup>24-3</sup>-1=2097151</td><td>2<sup>8</sup>-2=254</td><td>192.0.1</td><td>223.255.255</td><td>192.0.0</td></tr></tbody></table><p>ARP: Address Resolution Protocol<br>  实现IP地址向物理地址的映射</p><h1 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h1><p>TCP: Transmission Control Protocol<br>  提供用户间面向连接的，可靠的报文传输服务<br>UDP: User Datagram Protocol<br>  提供用户间无连接的，不可靠的报文传输服务</p><h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><p>SMTP: Simple mail transmission protocol<br>  简单的电子邮件发送服务<br>Telnet: Telcommunication network protocol<br>  远程登录服务（明文传输）<br>DNS: Domain Name System<br>  域名和IP地址映射<br>POP: Post Office Protocol<br>  提供对邮箱服务器进行远程存取邮件的服务，类似的还有IMAP<br>HTTP: HyperText Transfer Protocol<br>  浏览服务<br>SSH: Secure Shell<br>  加密的网络传输协议</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>diary</title>
    <link href="/2020/10/07/diary/"/>
    <url>/2020/10/07/diary/</url>
    
    <content type="html"><![CDATA[<p>今天和实验室朋友打了球还算开心。晚上看了下本泽直树，日剧在我心中的地位更低了。想我以前是多喜欢日剧来着。果然男人是<del>汇编</del>会变的啊。<br>看剧不如学习（狗头</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotKey</title>
    <link href="/2020/09/04/AutoHotKey/"/>
    <url>/2020/09/04/AutoHotKey/</url>
    
    <content type="html"><![CDATA[<p>AutoHotKey真不错，我用它稍微改造了一下俺的键盘哈哈哈，将ScrollLock和Pause键改造成音量加减了。真是便捷！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>AHK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Programming</title>
    <link href="/2020/08/18/Linear-Programming/"/>
    <url>/2020/08/18/Linear-Programming/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> scipy.optimize <span class="hljs-keyword">import</span> linproga = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])b = np.array([<span class="hljs-number">-7.9</span>])c = np.array([[<span class="hljs-number">-3.05</span>, <span class="hljs-number">-4.05</span>, <span class="hljs-number">-6.1</span>]])res = linprog(a, A_ub=c, b_ub=b)print(res)</code></pre><p>官方参考:<br><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html" target="_blank" rel="noopener">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PCA analysis</title>
    <link href="/2020/08/18/PCA-analysis/"/>
    <url>/2020/08/18/PCA-analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>用于数据降维，举例来说，太阳实际是<em>球体<em>，但一般可以说太阳是</em>圆的</em> 。这就是数据降维。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCAX = np.array([[<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>]])pca = PCA(n_components=<span class="hljs-number">2</span>) <span class="hljs-comment"># 数据维数，设置为'mle'是自动保留</span>pca.fit(X)print(pca.explained_variance_ratio_)&gt;&gt;&gt;[ <span class="hljs-number">0.99244</span>...  <span class="hljs-number">0.00755</span>...]print(pca.transform(X)) <span class="hljs-comment"># 做一个每一列到其他列的投影</span>&gt;&gt;&gt;[[ <span class="hljs-number">1.38340578</span>] [ <span class="hljs-number">2.22189802</span>] [ <span class="hljs-number">3.6053038</span> ] [<span class="hljs-number">-1.38340578</span>] [<span class="hljs-number">-2.22189802</span>] [<span class="hljs-number">-3.6053038</span> ]]</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo出现WARN No layout的解决方案其一</title>
    <link href="/2020/07/24/hexo%E5%87%BA%E7%8E%B0WARN-No-layout%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%85%B6%E4%B8%80/"/>
    <url>/2020/07/24/hexo%E5%87%BA%E7%8E%B0WARN-No-layout%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%85%B6%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>主题为 icarus - version 3.0.0，运行以下命令：</p><pre><code class="hljs Bash">npm install --save hexo-component-inferno@^0.3.0</code></pre><p>即可解决。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纪念室友第一次冷水澡</title>
    <link href="/2020/07/09/%E7%BA%AA%E5%BF%B5%E5%AE%A4%E5%8F%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%B7%E6%B0%B4%E6%BE%A1/"/>
    <url>/2020/07/09/%E7%BA%AA%E5%BF%B5%E5%AE%A4%E5%8F%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%B7%E6%B0%B4%E6%BE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年7月9日"><a href="#2020年7月9日" class="headerlink" title="2020年7月9日"></a>2020年7月9日</h1><p>今天，田老板在我鼓励下洗了冷水澡，浴室里回响着他的鬼哭狼嚎。纪念纪念hiahia</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaConstructor</title>
    <link href="/2020/06/15/JavaConstructor/"/>
    <url>/2020/06/15/JavaConstructor/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs java"><span class="hljs-comment">//SubCat.java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>  </span>&#123;    Cat (<span class="hljs-keyword">int</span> c)  &#123;        System.out.print (<span class="hljs-string">"cat"</span>+c+<span class="hljs-string">" "</span>);      &#125; &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubCat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cat</span>  </span>&#123;    SubCat (<span class="hljs-keyword">int</span> c)&#123;        <span class="hljs-keyword">super</span> (<span class="hljs-number">5</span>); <span class="hljs-comment">//work here.Specifies the superclass constructor,and must be at first line!!!</span>        System.out.print (<span class="hljs-string">"cable"</span>);    &#125;    SubCat()  &#123;          <span class="hljs-keyword">this</span> (<span class="hljs-number">4</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String  []  args)</span>  </span>&#123;        SubCat s= <span class="hljs-keyword">new</span> SubCat();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//CB.java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ca</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-comment">//Ca()&#123;&#125;; not worked,because CB calls the default parameterless constructor of the parent class by default</span>    Ca(<span class="hljs-keyword">int</span> num)&#123;            <span class="hljs-keyword">this</span>.num = num;            System.out.print(<span class="hljs-keyword">this</span>.num);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cb</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ca</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">2</span>;    Cb(<span class="hljs-keyword">int</span> num)&#123;        <span class="hljs-keyword">this</span>.num = num;        System.out.print(num);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;            Ca a = <span class="hljs-keyword">new</span> Cb(<span class="hljs-number">5</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//C.java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A func1 is calling"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;        func1();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B func1 is calling"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B func3 is calling"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//B a = new B();</span>        A a = <span class="hljs-keyword">new</span> B();        System.out.println(a.getClass());        a.func1();        a.func2();<span class="hljs-comment">//类型是B的类型，函数是B的函数</span>        <span class="hljs-comment">//a.func3(); not work,because Method func3 in undefined in class A</span>    &#125;&#125;</code></pre><ul><li>内部类可以向上转型。</li><li>内部类作为父类时不能向下转型。</li><li>如果有一个带形参的构造函数，编译器不会自动添加无参的构造函数。</li></ul><pre><code class="hljs java"><span class="hljs-comment">//Pen.java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pencil</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span> <span class="hljs-params">(String content)</span></span>&#123;        System.out.println( <span class="hljs-string">"Write"</span>+content);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RubberPencil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pencil</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span> <span class="hljs-params">(String content)</span></span>&#123;        System.out.println(<span class="hljs-string">"Rubber Write"</span>+content);    &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">erase</span> <span class="hljs-params">(String content)</span></span>&#123;      System.out.println( <span class="hljs-string">"Erase "</span>+content);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pen</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Pencil p=<span class="hljs-keyword">new</span> Pencil();        (( RubberPencil) p).write(<span class="hljs-string">"Hello"</span>);<span class="hljs-comment">//Runtime error</span>    &#125;&#125;</code></pre><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>constructor</tag>
      
      <tag>javaClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>how to download ortholog ID in KEGG</title>
    <link href="/2020/06/12/how-to-download-ortholog-ID-in-KEGG/"/>
    <url>/2020/06/12/how-to-download-ortholog-ID-in-KEGG/</url>
    
    <content type="html"><![CDATA[<ol><li>Go to <a href="https://www.genome.jp/dbget-bin/get_linkdb?-t+brite+gn:T00007" target="_blank" rel="noopener">LinkDB Search</a></li><li>Click <a href="https://www.genome.jp/kegg-bin/get_htext?eco00001" target="_blank" rel="noopener">eco00001</a></li><li>Select your species in drop-down list(Manually) &amp; Click the button “go”</li><li>Download “htext”</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>KEGG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>how to find the genome list of E.coli</title>
    <link href="/2020/06/10/how-to-find-the-genome-list-of-E-coli/"/>
    <url>/2020/06/10/how-to-find-the-genome-list-of-E-coli/</url>
    
    <content type="html"><![CDATA[<p>1.Search on Google with keyword “e coli mg1655 genomesGroup”</p><p>2.Click the link showed on the top.</p><p>3.Click the link on new page called <a href="https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?lvl=0&id=511145" target="_blank" rel="noopener">Escherichia coli str. K-12 substr. MG1655</a> </p><p>4.Click the “Genome|1” showed on the right of the page.</p><p>5.Find “Download genome annotation in <a href="https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff.gz" target="_blank" rel="noopener">GFF</a>, <a href="https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gbff.gz" target="_blank" rel="noopener">GenBank</a> or [tabular](<a href="https://www.ncbi.nlm.nih.gov/genome/browse/#!/proteins/167/161521|Escherichia" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/genome/browse/#!/proteins/167/161521|Escherichia</a> coli str. K-12 substr. MG1655/) format”, and choose “tabular format”.</p><p>6.Find “Download” button, download .csv format file.</p>]]></content>
    
    
    
    <tags>
      
      <tag>E.coli</tag>
      
      <tag>NCBI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notes</title>
    <link href="/2020/06/10/notes/"/>
    <url>/2020/06/10/notes/</url>
    
    <content type="html"><![CDATA[<ol start="5"><li><p>l型细菌不需要细胞分裂机制和细胞壁生物合成通路</p><p> 细胞壁是细菌细胞周围的层状结构。细胞壁的主要成分是肽聚糖(PG)，它是由短肽交联的长聚糖链组成的简单网状结构(Typas et al.， 2012)。肽聚糖壁是细菌王国的定义结构之一，合成肽聚糖壁所需的基因或通路通常对所有已知的主要细菌谱系的细胞生长都至关重要。肽聚糖壁是抗生素的靶点，如b-内酰胺和糖肽，而我们的先天免疫系统识别肽聚糖壁的碎片，帮助触发免疫反应.虽然有些细菌不具有细胞壁合成基因(如支原体和植物原体)，这很可能是因为他们失去了现代细菌祖先的细胞壁结构。因此，细胞壁可能出现在细菌进化的开始，也可能出现在细菌的最后共同祖先。</p><p> 尽管细胞壁在细菌生命中至关重要，但令人惊讶的是，在某些条件下(即在存在渗透保护剂如蔗糖的情况下)，人们已经知道细菌细胞能够恢复其祖先的壁缺失状态，即L-form(Allan et al.， 2009)。L-form被传统地分离为与多种传染病相关的抗生素耐药变异(Domingue和Woody, 1997)，自1935年被发现以来，人们已经对其进行了几十年的研究。</p><p> 通常情况下，几乎所有的细菌细胞都以二分裂的方式分裂。中央蛋白质在细胞分裂中是像微管蛋白FtsZ一样,在细胞中央形成一个环形结构，吸收其他与细胞分裂的相关的蛋白质,FtsZ分裂装置驱动了新细胞壁合成，促进子细胞产生(亚当斯和埃林顿,2009)。相反，L-form细胞通过一系列不受完全调控的机制分裂，包括膜挤压、起泡、小管化和囊泡化，随后自发分解成更小的子代(Kandler和Kandler, 1954年;Dell Era等，2009;Leaver等人，2009年;Briers等，2012)。值得注意的是，在几种细菌的L-form中，包括革兰氏阳性B. subtlis和革兰氏阴性大肠杆菌，这种所谓必要的FtsZ分裂机制和PG合成酶变得完全可有可无(Leaver et al.， 2009;Mercier等，2013,2014;Kawai等，2014)。相反，L-form的增殖主要是由生物物理效应驱动的，这种生物物理效应依赖于过量的膜合成，导致细胞表面积与体积比的增加(Mercier等，2013)。可以通过激活脂肪酸膜合成途径直接诱导膜合成的上调，也可以通过不明机制抑制PG前体通路间接诱导.</p><p> 最近试图了解生命的起源的体外实验和理论研究已经表明,脂肪酸分子自发融入简单的囊泡,导致增加表面积与体积比,足以驱动囊泡进行没有蛋白质基础机制的干预的复制(Hanczyc et al ., 2003;Peterlin等人，2009年;朱和绍斯塔克，2009年;布丁和绍斯塔克，2010年;Terasawa等，2012)。引人注目的是，各种L-form细胞分裂模式，包括膜挤压、起泡、小管化和囊泡化，似乎可以在体外简单的囊泡复制中实现。L-form的增殖模式可能在很多细菌中都是保守的(Mercier et al.， 2014)，因此，包括膜动力学在内的简单生物物理效应可能支持细胞的高效增殖。</p></li></ol><p>6.祖先脂肪酸的合成通路</p><p>​    如上所述，激活脂肪酸合成引起的过量磷脂膜合成可以促进原始细胞的增殖.这个模型中的一个难点是古细菌磷脂膜是与sn-甘油-1-磷酸连接的异戊二烯醚,而细菌膜磷脂是与sn-甘油-3-磷酸连接的脂肪酸酯. 细菌和古菌在膜特征上的巨大差异导致人们认为原始生命没有磷脂膜.然而，最近的研究表明，原始细胞膜的组成有另一种可能。系统基因组学分析表明，除了缺乏酰基载体蛋白(ACP)加工系统外，古菌的脂肪酸合成通路与细菌相似，说明原始细胞可能具有脂肪酸合成系统.Moreira和他的同事还讨论了原始细胞可能具有合成磷脂脂肪酸所需的其他酶活性，如snglycerol-3-磷酸氢化酶和胞苷二磷酸醇磷脂转移酶的活性.此外，在古菌细胞中实际检测到磷脂脂肪酸(Gattinger et al.， 2002;Pereto等，2004)。因此，磷脂脂肪酸的合成途径是原始的，磷脂膜可能已经在原始细胞中合成.</p><p>7.原始细胞增殖所需的基本模块:来源于L-form细胞分裂的概念</p><p>​    图2总结了估计的支持原始细胞像L-form增殖的基本模块;糖酵解是将遗传信息(基因组)传递给后代并读出基因组信息的过程，糖酵解提供能量化合物和乙酰辅酶a作为底物进行脂肪酸合成.f0f1 atp酶的质子在膜上的运输是维持pH恒定和质子动力所必需的.通过脂肪酸合成通路产生细胞膜，足以驱动如同l -form形式的细胞增殖。相比之下，通常必需的细胞壁合成途径和依赖FtsZ的细胞分裂系统对于细菌的生长是可有可无的。许多营养素，包括辅助因子、氨基酸和核苷酸，可以从古代地球上营养丰富的环境中获得.</p><p>​    支原体是一种动物共生体，由于其基因组小且缺乏细胞壁，已被用作构建最简单最小细胞的杰出模型。最近，Gibson和同事们成功地通过将化学合成的基因组(包括ftsZ)移植到M. capricolum受体细胞中，成功地培育出了一种人工的M. mycoides菌株.此外，也有报告成表明一些昆虫共生体的小基因组(144-422 kbp)仅保留处理遗传信息，一些氨基酸合成和维生素合成所需的基因.</p><p>​    这些共生体可能从它们的寄主昆虫那里获得各种营养来源，包括脂肪酸。因此，它们的基因组编码的数量极其有限的基本模块可能足以在营养丰富的环境下维持细胞生命.</p><p>​    L-form菌已经在人类、其他动物或植物中分离或检测到，但在实验室条件下长期培养它们通常非常困难，这说明一些L-form菌可能由于缺少一些仅在宿主环境中才有的因素而无法在宿主环境之外生长(Allan et al.， 2009)。这也可能暗示从亲本有壁细胞到l型的转变是在其宿主环境中<u>自然发生</u>的。例如，研究表明，通过有氧呼吸产生的活性氧类(ROS)对实验室条件下产生的L-form的生长有严重阻碍(Jutras和Jacobs-Wagner, 2015;Kawai等，2015)。因此，古老的地球环境:厌氧和营养丰富的环境(有许多代谢所需的简单化学物质，氨基酸，核苷酸，甚至脂肪酸)，可能是像l -form一样增殖的原始细胞所必需的.</p><p>​    许多研究试图在体外创造合成生命，以更好地理解细胞生命的基本属性。利用重组蛋白表达系统在体外复制DNA复制，该系统由纯化的亚单位组成，支持翻译和转录(即中心教义周期)(Fujiwara et al.， 2013)。膜泡的复制也通过向膜泡外部供应脂肪酸进行人工复制(Budin和Szostak, 2010)。DNA和囊泡复制/分离之间的联系可能是一个难以捉摸的，但在这个领域迷人的问题。</p><p>​    细胞是基本的结构，功能和最小的生命单位，可以复制产生子代。对最小基因集和基本模块的分析，可以重建自主复制的简单细胞，并有助于理解基因组在原始细胞生活</p>]]></content>
    
    
    
    <tags>
      
      <tag>L-form</tag>
      
      <tag>E.coli</tag>
      
      <tag>Essential gene</tag>
      
      <tag>bio-paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notes</title>
    <link href="/2020/06/09/notes/"/>
    <url>/2020/06/09/notes/</url>
    
    <content type="html"><![CDATA[<p>比较基因组学是估计最小基因集合的另一种方法。最初试图确定最小基因集合是由确定保守基因的基因组之间的寄生细菌,支原体genitarium携带468个蛋白编码基因,与小的流感嗜血杆菌基因组,携带1703个蛋白编码基因，结果，两个基因组中有240个同源基因被鉴定为保守基因。尽管Mushegian和Koonin发现在两种细菌中都缺少一些编码基本生化通路成分的同源基因，但两种细菌的<u>基本细胞功能都由非同源基因进行了补充</u>，这种现象被称为非同源基因替代non-orthologous gene displacement (NOGD)，在他们的对比研究中发现了22个NOGDs。此外，从最小基因集中筛选出6个功能冗余基因，确定最小基因集为256（240+22-6）个基因。后来，Gil和同事们通过比较几组基因组信息确定了几种细菌的最小基因集:(1)昆虫细菌内共生体中保存的蛋白质编码基因。(2)实验测定的大肠杆菌和枯草杆菌的Essential gene(3)生殖支原体的最小基因集和实验测定了生殖支原体和生殖支原体的近亲肺炎支原体的必要基因(4)金黄色葡萄球菌必需基因的研究和(5)小Phyroplasma asteris基因组，确定了266个基因是最小基因集。最小的基因集包括复制、转录、翻译、蛋白伴侣、运输、糖酵解、atp酶、磷酸酶途径、脂质代谢(不含脂肪酸合成，和昨日笔记类似)、核苷酸合成、辅助因子合成。Gil和他的同事们也指出,这个重要基因的最小集合是暂时性的并且几乎没有相关生命的起源的研究(Gil et al ., 2004)并且，可能实际上很难精确估计原始细胞的基因的最小基因集合。然而,这些分析基于直系同源分析,因此,每一个最小基因集可能含有的高度保守的基因进化信息</p><p>另一方面，Acevedo-Rocha及其同事指出，实验确定的大肠杆菌必要基因（Baba等，2006）在171个细菌基因组中的存在率非常低，在所有基因组中只发现了42个基因（14%），这说明从必要基因组中估计普遍的必要基因有很大的困难（Acevedo-Rocha等，2013）。如前一节和本节前面所述，由于基因功能的冗余、NOGD以及实验条件的差异，当用于比较的细菌种类数量增加时，必要基因的存在率较低，这并不奇怪。Azuma和Ota使用KEGG通路图直接估计了最小细胞功能。因为他们识别的是保守的通路，而不是保守的基因，所以NOGD的负面影响可能会减弱。他们成功地确定了由20条保守通路和21条生物特异性通路组成的大肠杆菌的最小通路图。</p><p>为了讨论基本细胞功能的保守性,我们基于广泛的细菌基本基因集，在细菌中使用KEGG模块完成比率(MCR) 分析了通路和涉及重要生物反应的功能结构(我们称为:基本模块)的保守程度，(见图1的说明,表S2)。由于每个KEGG模块都由多种通路组成，通过一系列反应产生代谢产物，因此这个分析可以避免由于途径或基因(或蛋白)的替代而产生的负面影响。结果如图1所示。脂肪酸生物合成(KEGG模块编号:M00083和M00082) 、PRPP生物合成(M00005)、辅酶A生物合成(M00120)和糖酵解(M00002)被认为是细菌中最保守的5个基本途径模块(图1B)。糖酵解是将葡萄糖转化为丙酮酸并产生能量化合物(ATP和NADH)的代谢途径。丙酮酸是必要的起始材料的好氧克雷布斯循环和厌氧发酵代谢。丙酮酸也转化为乙酰辅酶A(辅酶A)，用于脂肪酸生物合成途径的初始步骤。脂肪酸合成从乙酰辅酶a和丙二酰辅酶a合成乙酰乙酰基- acp开始，然后通过添加丙二酰辅酶a的乙酰基单位延长酰基链。辅酶A生物合成(M00120)对脂肪酸合成也是必不可少的(Magnuson et al.， 1993)。5-磷酸核糖合成5-磷酸基-1-二磷酸(PRPP)是核苷酸合成的第一步(Gil et al.， 2004)。如图1B所示，排在前10位的其余基本途径模块是核苷酸合成(M00050, M00052)、异戊二烯类生物合成(M00096)和四氢叶酸(THF)生物合成(M00126)。异戊二烯有助于膜稳定性(泰勒，1984)。THF对氨基酸和核苷酸的合成至关重要(Scott和Weir, 1998)</p><p>核糖体(M00178)、dna聚合酶III复合物(M00260)、RNA聚合酶(M00183)、f型atp酶(M00157)和脂蛋白释放系统(M00255)在细菌基本结构模块的保守度中排名前五(图1C)。因此，除f -型atp酶外，高度保守的结构模块与遗传信息处理、翻译(核糖体)、复制(dna -聚合酶III)和转录(RNA聚合酶)相关。f -型atp酶可能对产生质子动力和维持pH平衡至关重要(Xu et al.， 2011)。其余高度保守的模块在前10位分别是分泌系统(M00335)、细胞分裂转运系统(M00256)、ABC型转运系统(M00254)、脂多糖出口系统(M00320)和RNA降解系统(M00394)。M00335、M00256、M00254和M00320模块与膜转运有关，M00394参与遗传信息处理(Kanehisa et al.， 2016)。保守的KEGG<u>基本模组</u>与Gil及其同事确定的最小基因集所编码的通路重叠(Gil et al.， 2004)，表明最小基因集在进化中被保存为编码<u>基本模组</u>的基因。</p><p>有趣的是，E-cell项目表明，代谢途径包括:糖酵解生成ATP、利用外源性脂肪酸生物合成磷脂，转录和翻译机制可以支持代谢的平衡，但不能支持细胞分裂和基因组复制(Tomita et al.， 1999;吉尔等，2004)。E-cell项目估算的最小基因集与Gil及其同事的发现有很大的重叠，Gil及其同事排除了编码脂肪酸合成通路的基因，因为脂肪酸可以从环境中获得(Gil et al.， 2004)。然而，脂肪酸合成在原始细胞分裂中可能是重要的，因为脂肪酸合成的激活导致的过量膜合成会刺激原始细胞的增殖(见下一节)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>L-form</tag>
      
      <tag>E.coli</tag>
      
      <tag>Essential gene</tag>
      
      <tag>bio-paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notes</title>
    <link href="/2020/06/08/notes/"/>
    <url>/2020/06/08/notes/</url>
    
    <content type="html"><![CDATA[<p>大肠杆菌是革兰氏阴性菌，它有细胞壁，细胞膜。细胞壁有三层，一层外膜，一层肽聚糖(PG)，一层内膜。Essential genes是能够支持细菌生命的最小规模的基因集合，从计算和实验上识别出来了。但因为，我们并不知道原始细胞是如何生存增殖的，所以还是很难对出现在原始细胞里的远古基因和现在细胞内的Essential genes进行对比，因此也不能直接对对远古细胞内的基因重要性进行评价。<br>细胞壁通常对细菌的增殖很重要，有壁细菌细胞的分裂通常由必需的FtsZ细胞分裂机制高度控制。但细菌也可以转变成细胞壁缺失的远古形态: L-form。</p><a id="more"></a><p>与“正常”细胞不同的是，L-form细胞通过一种简单的基于膜动力学的物理机制分裂，表明在细胞壁出现之前，细胞就已经有了原始的增殖模式。在这篇综述中，我们总结了关于最小基因集的实验和计算研究，并讨论了支持原始细胞增殖所需的最小细胞模块，以L-form增殖为基础。</p><p>鉴定细菌的最小基因集将有助于我们理解细胞生命的原理。现在。多种细菌中细胞生存的Essential Genes都已经知道。遍布细菌区域的普遍必需基因可能代表了细菌生命所需的最小基因集。</p><p>Mushegian和Koonin估计了存在于生殖道支原体和流感嗜血杆菌中的最小基因集，因为这两种细菌至少在15亿年前就从它们的共同祖先种分离了，所以它们的基因都保存了下来，最小的基因集，就是祖先的基因，这些功能与转录、翻译、复制、DNA重组和修复、伴侣样蛋白、部分辅助因子合成、蛋白质输出和代谢产物转运系统(如atp酶)有关，而与氨基酸合成和脂肪酸生物合成无关。因为后两者可以从营养丰富的环境中获得。有趣的是，通过计算确定的最小基因集与实验确定的相似。因此，即使在实验或计算确定的最小基因集之间可能存在差异，每个最小基因集可能，至少部分，代表祖先的生命形式。</p><p>肽聚糖(PG)细胞壁是细菌界的一个决定性的结构特征。虽然细胞壁生物合成途径通常是细菌增殖所必需的，但我们已经知道许多细菌能够转换成无细胞壁的L-form状态。几乎所有处于正常壁态的细菌细胞都通过依赖ftsz的细胞分裂机制进行二分裂。然而在L-form细胞里，这种必要的细胞分裂机制连同细胞壁合成酶变得完全可有可无。相反反，L-form细胞的增殖是由一个简单的生物物理过程驱动的，这个过程的基础是表面积与<em>细胞体积合成</em>的比例增加，从而导致细胞形状变形，导致细胞分裂。这种简单的L-form增殖机制符合原始细胞可能的复制机制，这是几项体外和理论研究的结果，表明L-form可能类似于几十亿年前细胞壁出现之前的早期细胞生命。</p><p>在这篇综述中，我们总结了迄今为止在计算和实验上鉴定最小基因集的努力，并讨论了可能的最小细胞功能，以支持原始细胞增殖的l型观察。我们设想从实验中鉴定的最小基因集估计的保守的Essential模块可以支持原始细胞的l型增殖模式。</p><p>随机转座子诱变已被用作细菌基因组中必需区域全基因组鉴定的首选方法。转座子是可移动的遗传元件，可随机整合到基因组DNA中。当转座子整合到细菌基因组的一个必要区域，包括必要蛋白质/rna 的编码区域或非编码必要区域，如复制起点或必要基因的转录调节元件;由此产生的突变体是不可活的，因此不应该从转座子库中分离出来。多项研究通过高通量测序或芯片技术鉴定了10^3到10^6个整合位点，并将转座子游离基因组区确定为必需基因组区。许多必需基因在各种细菌中广泛分布，炭疽芽孢杆菌的最佳生长、产孢和萌发需要253个基因，而在营养丰富的培养基中生长霍乱弧菌需要789个基因。Christen和他的同事最近报道了一项利用超饱和转座子诱变策略对菜花杆菌的必要编码和非编码染色体元件进行的详尽分析，在此研究中，转座子被整合到花椰菜杆菌的基因组中;转座子插入在突变体库中的饱和程度非常高，理论上每8个bp就插入一个转座子，并且有12.19%的基因组区域被确定为必需的。这些区域包括480个蛋白编码区和130个非编码区。此外，402个区域被认为是控制基因表达的关键。</p><p>另一种系统鉴定必需基因的方法是直接灭活基因，在这种策略中，目标基因直接被标记基因(通常是耐药性基因)取代，或者被插入带有标记基因的DNA片段打断。如果突变体没有被分离出来，靶基因被认为是细胞生长所必需的。分别在大肠杆菌和枯草芽孢杆菌中制作了数千个基因敲除突变体，这些敲除实验的结果表明，大肠杆菌的303个基因和枯草芽孢杆菌的271个基因对LB培养基中细胞的生长至关重要。大肠杆菌和枯草芽孢杆菌中的Essential gene最近在不同生长条件下或使用不同的基因敲除方法被重新评估(连续系统删除,见表S1),结果表明，在大肠杆菌和枯草芽孢杆菌中，分别有295和259个基因是必不可少的。Xu和同事使用直接基因灭活策略仔细评估了血链球菌基因的重要性，并在基因组中鉴定出218个必需基因。</p><p>尽管如上所述对鉴定各种细菌的必需基因进行了广泛的研究，但由于缺乏清晰的保存模式，无法对细菌基因组中的普遍最小基因集进行合理的预测。在细菌进化过程中获得的基因重复、多个基因的功能冗余和替代代谢途径补充了某些基因或途径的必要性，并混淆了必要最小基因集的描述。</p><p>Essential Gene定义的差异也可能是由于不同实验室用于评估基因的必要性的实验方法或条件的不同(表S1)。大肠杆菌K-12基因的重要性主要通过两种不同的策略来评估，随机转座子突变和直接基因灭活。Baba等人估计在随机诱变和靶向基因敲除实验中有205个基因是必需的，仅占Gerdes等人确定的必需基因的67%。Baba等人的研究表明，有92个突变体在LB培养基中(培养22小时后OD600 0.52e0.95)生长健康，但在MOPS最低培养基中并不是如此(OD600&lt;0.08，培养48h后)。在MOPS最小培养基中生长所需的基因在氨基酸、核苷酸和维生素代谢或运输中发挥作用，这与这些化学物质在复杂生长培养基(如LB)中的存在和在明确的简单培养基(如MOPS最小培养基)中的缺失是一致的。不同菌种必需基因的差异也可以解释为它们偏好的栖息地的不同。细菌可能需要不同的基因集才能在不同的生态环境中生存。与此相一致的是，肠内大肠杆菌和土壤枯草b菌中与应激反应相关的必要基因并不重叠</p>]]></content>
    
    
    
    <tags>
      
      <tag>L-form</tag>
      
      <tag>E.coli</tag>
      
      <tag>Essential gene</tag>
      
      <tag>bio-paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Things-to-do in this weekend</title>
    <link href="/2020/06/08/Things-to-do-in-this-weekend/"/>
    <url>/2020/06/08/Things-to-do-in-this-weekend/</url>
    
    <content type="html"><![CDATA[<ol><li>Python版本管理:anaconda+pycharm</li><li>Java版本管理:eclipse</li><li>代码版本管理:git-github</li><li>文件版本管理:svn</li><li>文件分类控制</li><li>重复文件清理</li><li>程序位置转移</li><li>浏览器收藏夹整理</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Master Sketching on Windows 10 18363 x64 &amp; Ubuntu18.04.2 x64</title>
    <link href="/2020/06/07/Master-Sketching-on-Windows-10-18363-x64-Ubuntu18-04-2-x64/"/>
    <url>/2020/06/07/Master-Sketching-on-Windows-10-18363-x64-Ubuntu18-04-2-x64/</url>
    
    <content type="html"><![CDATA[<p>注意，<code>torch v0.4.1</code>似乎并不支持<code>python3.8</code>,故使用<code>python3.6</code>.<code>Ubuntu18.04.2</code>自带的python3版本就是<code>Python3.6</code><br>个人配置供参考：<code>i5-10210U DDR4-12GB MX250-2GB</code></p><p>需要对<code>Master Sketching</code>文件夹内<code>simplified.py</code>文件进行两处修改。</p><pre><code class="hljs Python"><span class="hljs-comment"># simplified.py</span>use_cuda=<span class="hljs-number">0</span>load_lua(opt.model,long_size=<span class="hljs-number">8</span>)</code></pre><p><code>Ubuntu</code>为虚拟机环境<code>Vmware Workstation Pro 15.5.1</code>, <code>Ubuntu 18.04.2</code>, <code>4GB RAM</code>, <code>40GB Disk</code>, <code>Cpu 2x2</code>核心</p><pre><code class="hljs Bash"><span class="hljs-comment"># Ubuntu18.04.2 X64</span>sudo apt install python3-pippip3 install pippip3 install torch==0.4.1pip3 install torchvision==0.2.1</code></pre><p><code>Windows10</code>需要安装<code>Anaconda</code>，在<code>https://repo.anaconda.com/archive/</code>内下载安装<code>Anaconda3-2020.02-Windows-x86_64.exe</code> ，之后打开<code>Anaconda prompt</code></p><pre><code class="hljs Bash"><span class="hljs-comment"># Conda,Windows10 x64</span>pip install pippip install torch==0.4.1pip install torchvision=0.2.1</code></pre><p>一切就绪后即可在对应目录下使用如下命令输出<code>out.png</code>图片啦</p><pre><code class="hljs Bash"><span class="hljs-comment">#Ubuntu</span>python3 simplified.py</code></pre><pre><code class="hljs Bash"><span class="hljs-comment">#conda,Windows 10</span>python simplified.py</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo Icarus sociallink修改</title>
    <link href="/2020/06/06/hexo-Icarus-sociallink%E4%BF%AE%E6%94%B9/"/>
    <url>/2020/06/06/hexo-Icarus-sociallink%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<p>本文目的在于修改hexo的主题icarus,version 3.0.0版本下的sociallink图标，弃用icarus本身提供的<a href="fontawesome.com" title="fontawesome">fontawesome</a> 图标。个人原因是该网站图标颜色太单调，想鲜明一点。<br>操作系统:win10 18363 64位,使用git进行<code>hexo clean;hexo g;hexo deploy</code>，具体环境如下。</p><pre><code class="hljs git"># check versions in git$ git --versiongit version 2.27.0.windows.1$ hexo -vhexo: 4.2.1hexo-cli: 3.1.0os: Windows_NT 10.0.18363 win32 x64node: 12.18.0v8: 7.8.279.23-node.37uv: 1.37.0zlib: 1.2.11brotli: 1.0.7ares: 1.16.0modules: 72nghttp2: 1.41.0napi: 6llhttp: 2.0.4http_parser: 2.9.3openssl: 1.1.1gcldr: 37.0icu: 67.1tz: 2019cunicode: 13.0</code></pre><p>首先打开<code>hexo\themes\icarus</code>目录下的_config.yml文件，在前几行里可以找到icarus的版本是3.0.0。<br>用编辑器打开 <code>hexo\themes\icarus\layout\widget\profile.jsx</code>文件，定位到14行，把</p><pre><code class="hljs jsx">&#123;<span class="hljs-string">'icon'</span> <span class="hljs-keyword">in</span> link ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#123;link.icon&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span> : link.name&#125;</code></pre><p>修改成</p><pre><code class="hljs jsx">&#123;<span class="hljs-string">'icon'</span> <span class="hljs-keyword">in</span> link ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;link.icon&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 20px;width: 20px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span></span> : link.name&#125;</code></pre><p>此句的目的在于，将图标的来源改成本地图片，而不是官方钦定的fontawesome格式。其中height和width表示图片的宽度和高度（仅测试长宽都是20px）。<br>修改完之后保存，这样我们就能使用本地的图片了。请注意，不要添加任何别的语句，以双斜杠开头的语句并不是注释！不要用C/Java的想法！我就以为双斜杠是注释，debug了好久。<br>我选择阿里巴巴矢量图标库 <a href="https://www.iconfont.cn/collections/index" target="_blank" rel="noopener" title="iconfont">iconfont</a> 作为我的图标来源。进入后搜索weibo,facebook,github的图标，选择自己喜欢的，下载<code>.svg</code>格式到本地（仅测试<code>.svg</code>格式）。<br>请注意，使用Chromium核心的Edge浏览器下载图标的时候，请一定等他病毒扫描完毕，下载完全结束后再对图标文件进行移动操作，不然可能会导致后续的bug。<br>下载完成后，务必把图标移动到<code>hexo\themes\icarus\source</code>目录下的任意位置，因为在<code>_config.yml</code>里引用的文件都是以source为基目录开始的。可以新建文件夹放图标，也可以放到img文件夹里。<br>我本人把所有图标放置在<code>hexo\themes\icarus\source\icons</code>目录下<br>再次打开<code>hexo\themes\icarus</code>目录下的<code>_config.yml</code>文件<br>首先使用编辑器的查找功能，查找 social ，定位到social_links关键字。此时我们可以把icon: 后面的语句写成自己的刚刚的图片位置了。我的图片放置在<code>hexo\themes\icarus\source\icons</code>下，那么我就需要把原来的<code>icon</code>行写成<code>icon: \icons\github.svg</code> 此处也要注意，icon的冒号后面需要加一个空格，不然会导致错误。<br>保存好之后，就可以在hexo目录下使用<code>hexo clean;hexo g;hexo s</code>三连啦，浏览器打开<code>localhost:4000</code>看看效果吧~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/05/08</title>
    <link href="/2020/05/08/2020-05-08/"/>
    <url>/2020/05/08/2020-05-08/</url>
    
    <content type="html"><![CDATA[<p>好久好久没更新了哇。最近开了好多坑，越学越感觉学无止境。Java，MySql，设计模式，深入理解计算机系统，C/C++，Python，似乎就没有好好学习本身的研究方向？听说力扣每个月满打卡有勋章，那么5月打卡题争取全部AC吧。尽量独立完成，实在不行再看。 喝了肥宅快乐水疯狂嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝嗝 &gt;..&lt; (这个表情包是我打英文句号的时候突然发现的哈哈哈，因为按住了shift。之前想的博客风格转换到现在还没有实操，属实弟弟，不过现在这样或许也不错，什么时候魔改一下？（可能永远都不哈哈哈 Update: 新开坑再算上EVE Online，另外LOL基本就这样了吧，技术基本在黄金~白金之间了。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/04/18</title>
    <link href="/2020/04/18/2020-04-18/"/>
    <url>/2020/04/18/2020-04-18/</url>
    
    <content type="html"><![CDATA[<p>悟出了一些道理，也不用说出来，心中知道就好啦</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/04/13</title>
    <link href="/2020/04/13/2020-04-13/"/>
    <url>/2020/04/13/2020-04-13/</url>
    
    <content type="html"><![CDATA[<p>Rstudio下，运行<code>install.packages(&quot;BiocManager&quot;)</code>之后遇到问题： <code>Installation path not writeable, unable to update packages: boot, class, foreign, lattice, MASS, nlme, nnet, survival</code> 尝试使用管理员权限运行Rstudio后重新安装。问题得以解决。 R语言获取一个包的帮助目前看到有两种方法： 一种是<code>help(package=&quot;clusterProfiler&quot;)</code>，这个会蹦出一个网页来。 另一种是<code>ls(&quot;package:clusterProfiler&quot;)</code>，这个会在Clis里输出 在上述ls命令之后，会列出一些方法名称。需要用以下命令之一查看具体细节： <code>help(go2term)</code>   #此处方法不加引号，不加前缀 <code>??clusterProfiler::go2term</code> 如果只要<code>??go2term</code> 会列出其他一些相关的方法，它的search方法很迷，网页里会蹦出一些包括go，包括term，或者两者都不包括的内容</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020/04/09</title>
    <link href="/2020/04/09/2020-04-09/"/>
    <url>/2020/04/09/2020-04-09/</url>
    
    <content type="html"><![CDATA[<p>断舍离大概第二天。移除了一些不需要的物件，让自己更专心于眼前的事情。 今天试着做了一些人机交互课程的分析，真的难受。Octave真的太诡异（无贬义）了。 举例来说： a=[1,1,2,2,3,3];b=[1,2];sum(a==b);居然能出结果，结果是[1 1 1 1 0 0] a=[1,2;3,4];b=[2,2;3,4];sum(a==b);返回[1 2] a=[1,2,4];b=[1;2];sum(a==b);返回[1 1 0]</p><pre><code class="hljs Python"><span class="hljs-comment"># Octave</span>a=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>];b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];sum(a==b);%[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];b=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];sum(a==b);%[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>];b=[<span class="hljs-number">1</span>;<span class="hljs-number">2</span>];sum(a==b);%[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>]</code></pre><p>对此爷只能说<div style="text-align:center"> <img src="https://i.loli.net/2020/10/02/Ar4qk9hGClHBXMo.png" srcset="/img/loading.gif" alt="爷晕晕"></div></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/04/07</title>
    <link href="/2020/04/07/2020-04-07/"/>
    <url>/2020/04/07/2020-04-07/</url>
    
    <content type="html"><![CDATA[<p>一则本来应该是0406的短篇 又想到了思索过很多次的问题，人活着的价值何在。作为一个与社会紧密相连的人，所谓的“存在感”并不是那么强烈。就扮演的诸多角色而言，都是可以被替代的。社会少了谁都一样运转，而“价值”只有在亲密关系中才会得以体现。所有的亲密关系里，体验着的有父子母子中的子，有亲朋的朋。曾体验过的有恋爱中的一方。就经历的人生而言，还失却了夫妻中的夫，父子/父女中的父。体验过的人生还不完整，但又好像干劲不足。动力不知从何而来，源自自我的动力似乎从来都不够充足，而以外界为动力应当不是正途？而又有言，不同人有不同活法，人生有梦各自精彩。还没找到足够令自己舒服的节奏，甚是无奈</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/31</title>
    <link href="/2020/03/31/2020-03-31/"/>
    <url>/2020/03/31/2020-03-31/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.wang/leetcode-142-Linked-List-CycleII.html" target="_blank" rel="noopener">https://leetcode.wang/leetcode-142-Linked-List-CycleII.html</a> 奇妙的快慢指针。第一次从0开始快慢指针找到环内的相遇点，第二次从0，从相遇点开始的双指针可以找到环的入口点</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/29</title>
    <link href="/2020/03/29/2020-03-29/"/>
    <url>/2020/03/29/2020-03-29/</url>
    
    <content type="html"><![CDATA[<p>走高速的感觉真的不一样。之前一次遇到猫躺在路边，今天的道路充溢着高速的车轮带起的水雾，似是人间仙境。但心中确是知道，一旦出事可能就是万劫不复，这种反差给了我一些冲击。 Edge着实是一款好游戏，它让我学会了双陆棋以及the domino两款游戏。 最近的steam有很多免费游戏啊，领了不知道多少个。有一个叫做drawful2,可惜连不上外网服务器没玩成。另外心心念念的Poly bridge又史低了，入手入手。很有意思的一款小游戏。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/24</title>
    <link href="/2020/03/24/2020-03-24/"/>
    <url>/2020/03/24/2020-03-24/</url>
    
    <content type="html"><![CDATA[<p>今天知道为什么Linker被缩写为ld了。 Linkers in Linux were originally called loaders.</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/18</title>
    <link href="/2020/03/18/2020-03-18/"/>
    <url>/2020/03/18/2020-03-18/</url>
    
    <content type="html"><![CDATA[<p>今日看Python看到 <strong>nonlocal 关键字</strong>，不得不说Python乱七八糟的定义还很多，宅摘抄一段描述: 使用 <strong>nonlocal</strong> 的好处是，在为函数添加状态时不用额外地添加全局变量，因此可以大量地调用此函数并同时记录着多个函数状态，每个函数都是独立、独特的。针对此项功能其实还个一个方法，就是使用类，通过定义__call__可实现在一个实例上直接像函数一样调用。比如这句前面就应该加一句 <strong>nonlocal count</strong><div style="text-align:center"><img src="https://i.loli.net/2020/10/02/vDSXbsFc4ra6Azn.png" srcset="/img/loading.gif" alt="nonlocal"></div></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/16</title>
    <link href="/2020/03/16/2020-03-16/"/>
    <url>/2020/03/16/2020-03-16/</url>
    
    <content type="html"><![CDATA[<p>今天学到，为什么python的类下面的直属变量没有self作为开头，因为这些变量是属于python的类的。调用的时候需要用 类名.变量名 的方式调用（包括类内函数对该变量的调用）。而__init__函数下面，以及其他函数下面，都是带self的，因为这是属于类的对象的。调用的时候需要用 对象名.变量名的方式调用。</p><p>如果一个类下面有一个变量为a，一个对象下面也有a，对象下面的a比类优先。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/13</title>
    <link href="/2020/03/13/2020-03-13/"/>
    <url>/2020/03/13/2020-03-13/</url>
    
    <content type="html"><![CDATA[<p>好记性不如烂笔头，先记下。 <code>matrix = map(list, zip(*matrix))</code></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/08</title>
    <link href="/2020/03/08/2020-03-08/"/>
    <url>/2020/03/08/2020-03-08/</url>
    
    <content type="html"><![CDATA[<p>今日见闻：高速上一只黑白花猫躺在路边（估计是死了），无血迹。 Python里，注意迭代，enumerate所创建的enumerate object，每次for循环都会指向下一个，结束的时候如果再次调用，会返回StopIteration 另外学会了初步的状态压缩。此外，成也Python，败也Python。用Python的时候千万千万要仔细。今天的失误在于，函数名里写的全称direction，下面调用的时候写成缩写dir，结果不对，但是没有报错！需要引起重视。另外，python的类里面，函数的调用要写成self.函数名(参数)，类中根目录下的变量在函数里调用的时候应当写成self.变量名的形式</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020/03/02</title>
    <link href="/2020/03/02/2020-03-02/"/>
    <url>/2020/03/02/2020-03-02/</url>
    
    <content type="html"><![CDATA[<p>今日踩坑：<code>np.sum(a[a:b,c:d])</code>，不应是<code>a[a:b][c:d]</code></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/29</title>
    <link href="/2020/02/29/2020-02-29/"/>
    <url>/2020/02/29/2020-02-29/</url>
    
    <content type="html"><![CDATA[<p>已经忘记四年前的今天在做什么了。四年后的今天，因为疫情没有开学，在家做了一个死宅。不值得纪念但也值得纪念。一杯敬过往<img src="/img/2020pic/02/IMG_20200229_233445-scaled.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/28</title>
    <link href="/2020/02/28/2020-02-28/"/>
    <url>/2020/02/28/2020-02-28/</url>
    
    <content type="html"><![CDATA[<p>今天调试python遇到问题，多线程的东西还是不能在spyder或者VScode或者jupyter里面调试，换成命令行就行了。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/23</title>
    <link href="/2020/02/23/2020-02-23/"/>
    <url>/2020/02/23/2020-02-23/</url>
    
    <content type="html"><![CDATA[<p>今日幸福份额：</p><p><img src="https://i.loli.net/2020/10/02/uGs9dYWz3oVc15I.png" srcset="/img/loading.gif" alt="我画的傻猫！"></p><p>以及： </p><p><img src="https://i.loli.net/2020/10/02/S2VtHlj3D5swKNQ.png" srcset="/img/loading.gif" alt="力扣小纪录.png"></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/21</title>
    <link href="/2020/02/21/2020-02-21/"/>
    <url>/2020/02/21/2020-02-21/</url>
    
    <content type="html"><![CDATA[<p>一山更有一山高~多学习 python的奇巧淫技真的多….绝了。矩阵转置等等。。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/16</title>
    <link href="/2020/02/16/2020-02-16/"/>
    <url>/2020/02/16/2020-02-16/</url>
    
    <content type="html"><![CDATA[<p>今天打算做一个今年的煎蛋无聊图+热评合集，年底放出来~有人说目标不要公开比较好，但是我觉得有时候说出来还是很有必要的 今天还回顾了一些氰化欢乐秀，挺有意思。另外<a href="https://www.youtube.com/watch?v=CZlfbep2LdU" target="_blank" rel="noopener">Beep Beep I’m a Sheep</a>真的很好听！ 另外<a href="http://rulesoftheinternet.com/" target="_blank" rel="noopener">Rules of Internet</a> 了解一下~英国古代牧羊犬和缅因猫都很棒✌</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/15</title>
    <link href="/2020/02/15/2020-02-15/"/>
    <url>/2020/02/15/2020-02-15/</url>
    
    <content type="html"><![CDATA[<p>吃鸡很无聊，LOL很无聊，还是听听音乐吧~LZY的歌单挺好的，收藏收藏</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/12</title>
    <link href="/2020/02/12/2020-02-12/"/>
    <url>/2020/02/12/2020-02-12/</url>
    
    <content type="html"><![CDATA[<p>吃到鸡了！日常俯卧撑+背单词</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/11</title>
    <link href="/2020/02/11/2020-02-11/"/>
    <url>/2020/02/11/2020-02-11/</url>
    
    <content type="html"><![CDATA[<p>背单词，俯卧撑~和往常一样。13号和20号的组会取消了，开心</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/10</title>
    <link href="/2020/02/10/2020-02-10/"/>
    <url>/2020/02/10/2020-02-10/</url>
    
    <content type="html"><![CDATA[<p>昨日咕咕咕了。今天真的有学习！为了拿交大的文创产品嘿嘿嘿。具体可关注上海交通大学微博。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/08</title>
    <link href="/2020/02/08/2020-02-08/"/>
    <url>/2020/02/08/2020-02-08/</url>
    
    <content type="html"><![CDATA[<p>每天健身没落下😀，但是又没有学习。好想剪头发啊啊啊啊啊，希望疫情快过去。今天学到个新名词，白月光。他们说如果只有一个前任，那么那个前任就好像白月光！</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/07</title>
    <link href="/2020/02/07/2020-02-07/"/>
    <url>/2020/02/07/2020-02-07/</url>
    
    <content type="html"><![CDATA[<p>终于领到了mirror，噫怎么是这样的游戏啊。sein患病，希望他快点好起来，看到了煎蛋的力量，感动</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/06</title>
    <link href="/2020/02/06/2020-02-06/"/>
    <url>/2020/02/06/2020-02-06/</url>
    
    <content type="html"><![CDATA[<p>今天单词还是没背。。不过有锻炼！有剧本杀！</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/05</title>
    <link href="/2020/02/05/2020-02-05/"/>
    <url>/2020/02/05/2020-02-05/</url>
    
    <content type="html"><![CDATA[<p>今天除了早起。。啥也没干成好像</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/04</title>
    <link href="/2020/02/04/2020-02-04/"/>
    <url>/2020/02/04/2020-02-04/</url>
    
    <content type="html"><![CDATA[<p>今日一觉睡到12点，然后剧本杀狼人杀…</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/03</title>
    <link href="/2020/02/03/2020-02-03/"/>
    <url>/2020/02/03/2020-02-03/</url>
    
    <content type="html"><![CDATA[<p>今天做了很多俯卧撑~</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/02</title>
    <link href="/2020/02/02/2020-02-02/"/>
    <url>/2020/02/02/2020-02-02/</url>
    
    <content type="html"><![CDATA[<p>给师大捐款啦~开心~</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/02/01</title>
    <link href="/2020/02/01/2020-02-01/"/>
    <url>/2020/02/01/2020-02-01/</url>
    
    <content type="html"><![CDATA[<p>曾想，扫好门前雪，勿管他人瓦上霜。但今天买的双黄连让我实在是无话可说。无论身在何方，总会有不正确的事发生。从之前的口罩不分，到现在的双黄连。越来越觉得读书的目的之一是在于提升自己质疑的能力，探寻真理的能力。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/31</title>
    <link href="/2020/02/01/2020-01-31/"/>
    <url>/2020/02/01/2020-01-31/</url>
    
    <content type="html"><![CDATA[<p>忘记总结的第二天，今日死宅，晒太阳看小说。学了点日麻，无奈运气实在不行。。实验室又分配任务了，旧任务还没完成呢</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/30</title>
    <link href="/2020/01/31/2020-01-30/"/>
    <url>/2020/01/31/2020-01-30/</url>
    
    <content type="html"><![CDATA[<p>剧本杀还是有趣哒。世界真小，研究生会的同学居然和之前某家公司的HR是高中室友，绝了····</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/29</title>
    <link href="/2020/01/29/2020-01-29/"/>
    <url>/2020/01/29/2020-01-29/</url>
    
    <content type="html"><![CDATA[<p>魔镜的激活码没有领到，试玩网页版青蛙分数，居然是flash，好无聊的游戏。围观了一会儿剧本杀，打了一下午斗地主。斗地主还是2v2，一队有个人走了就赢了，神奇</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/28</title>
    <link href="/2020/01/28/2020-01-28/"/>
    <url>/2020/01/28/2020-01-28/</url>
    
    <content type="html"><![CDATA[<p>下午剧本杀，又是一次杀手，编故事还是太难啊…东京大饭店这部日剧还是不错的。<a href="https://www.waijutv.com/index.php/vod/play/id/19855/sid/1/nid/1/" target="_blank" rel="noopener">https://www.waijutv.com/index.php/vod/play/id/19855/sid/1/nid/1/</a> 每一个投身料理领域的人，刚开始都不知道自己有没有天赋，不过，越是努力，越是磨练自己的本领，越能发觉自己的天赋。用在别的领域也是如此，越努力，越幸运吧。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/27</title>
    <link href="/2020/01/27/2020-01-27/"/>
    <url>/2020/01/27/2020-01-27/</url>
    
    <content type="html"><![CDATA[<p>都快月底了，回到家之后又陷入了低迷状态，看看电影吧，明天剧本杀？今天看到的婚姻故事还是不错。</p><p>waiting is the hardest part，做自己，让自己有活着的感觉</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/26</title>
    <link href="/2020/01/26/2020-01-26/"/>
    <url>/2020/01/26/2020-01-26/</url>
    
    <content type="html"><![CDATA[<p>在家无聊，玩玩picross，玩玩炉石，玩玩lol，看看书，真的无聊无聊无聊。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/25</title>
    <link href="/2020/01/25/2020-01-25/"/>
    <url>/2020/01/25/2020-01-25/</url>
    
    <content type="html"><![CDATA[<p>啊啊啊玩到一款好玩的游戏，叫做Picross。大家快去玩wwww。在助教空间看到，类似数独，但有趣的多。Steam和Google Play上面的都可以玩，前者有个免费的，叫做<a href="https://store.steampowered.com/app/476460/Picross_Touch/" target="_blank" rel="noopener">Picross Touch</a>，非常棒！！！非常棒！！无论配色，难易度，操作手感，成就系统，都是一等一的优秀，感谢作者！！！还是免费的！！！新年第一件开心的事！！！不过真的杀时间。<img src="/img/2020pic/01/picross2.png" srcset="/img/loading.gif" alt="">)<img src="/img/2020pic/01/picross.png" srcset="/img/loading.gif" alt="">)<img src="/img/2020pic/01/picross3.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/24</title>
    <link href="/2020/01/24/2020-01-24/"/>
    <url>/2020/01/24/2020-01-24/</url>
    
    <content type="html"><![CDATA[<p>一年又结束了。今天看了唐探1和幽灵公主。唐探1纯喜剧了，还算有意思，不过很多细节经不起推敲，也无妨，喜剧而已不必较真。幽灵公主算是一部值得思考的动漫了。人与自然相处的度在哪里？霓虹能有这么一位动漫大师真的幸运。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/23</title>
    <link href="/2020/01/23/2020-01-23/"/>
    <url>/2020/01/23/2020-01-23/</url>
    
    <content type="html"><![CDATA[<p>万物皆有裂隙，那是光照进来的地方。 理发店业已关门，组会倒是正常开。众所周知，病毒会通过网络传播~<img src="https://i.loli.net/2020/10/02/5uZqHESYhBX48Cg.png" srcset="/img/loading.gif" alt="年前照常的组会"> 什么时候发觉自己上了年纪了？当我喜欢酒的味道，喜欢原味瓜子，不喜欢漫长的排位与匹配，喜欢无限火力乱按键盘的时候。 回家感觉真不好，没有接收到什么正能量，没有什么开心的事。@煎蛋网友</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/22</title>
    <link href="/2020/01/22/2020-01-22/"/>
    <url>/2020/01/22/2020-01-22/</url>
    
    <content type="html"><![CDATA[<p>死宅的一天，（因为下雨？）只走了500步，安装了个cytoscape，随便鼓捣了两下子，也没学习，游戏也没好好打。下回来阴阳师，玩了一会发现还有点意思emm，但估计也是隔几天就删的吧。无聊无聊，又因为肺炎，更是无聊</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/21</title>
    <link href="/2020/01/21/2020-01-21/"/>
    <url>/2020/01/21/2020-01-21/</url>
    
    <content type="html"><![CDATA[<p>日记是每天的记录，需要反思与沉淀。倘若只是单纯的记录，收获必不会多。今日与旧友聊天散步，又接触到一些基金相关知识。曾哥靠谱，ore gay!</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/20</title>
    <link href="/2020/01/20/2020-01-20/"/>
    <url>/2020/01/20/2020-01-20/</url>
    
    <content type="html"><![CDATA[<p>今日总算游到了泳，虽然不多，700米，还算快乐。午饭恰了@孟 的蛋炒饭，干了点但是挺好吃。顺手还牵走一只酱鸭和一条鱼干，以后尝尝。晚上逛的超市，居然有麻雀。看了一下午+一晚上的灌篮高手，似乎并没有那么喜欢看。。只是打发一下时间而已。刷漫的意义到底在哪里，不懂。<img src="https://i.loli.net/2020/10/02/m5sVKvkQGw7Rd9S.jpg" srcset="/img/loading.gif" alt="孟大师手作炒饭"></p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/19 Diary</title>
    <link href="/2020/01/19/diary/"/>
    <url>/2020/01/19/diary/</url>
    
    <content type="html"><![CDATA[<p>今日睡了个懒觉，不得不说家里的被子比学校里舒服多了。快到中午去了趟健身房，被人说爆发力还行，耐力不行。以前可是完全反过来的人啊。在健身房莫名其妙被分到一个柑橘，出来去游泳馆的路上还被鸟屎淋了袖子，绝了。不过成功把myf叫出来游泳了，淋个鸟屎也不算什么。夜里出门终于穿上了喜欢的ECNU鞋，沿着西湖乱走，闲聊，回家的时候还看到了什么爱国主义专线，绝了。斑马线边上居然有灯，还是很不错的。图的话就乱序放了，随便看看。<br><img src="https://i.loli.net/2020/10/02/Rrbi3sDtTac8uPy.jpg" srcset="/img/loading.gif" alt="爱国教育"><br><img src="https://i.loli.net/2020/10/02/iVTwoP5u1Qkvrcl.jpg" srcset="/img/loading.gif" alt="夜西湖"><br><img src="https://i.loli.net/2020/10/02/CSOH4qeda7s19WJ.jpg" srcset="/img/loading.gif" alt="西湖边斑马线"><br><img src="https://i.loli.net/2020/10/02/Lt7DTqkwijyQAcr.jpg" srcset="/img/loading.gif" alt="鸟屎"><br><img src="https://i.loli.net/2020/10/02/q72OMk6unC5yQ39.jpg" srcset="/img/loading.gif" alt="健身房人送的水果"><br><img src="https://i.loli.net/2020/10/02/ItBr9NekfKzQgSi.jpg" srcset="/img/loading.gif" alt="大运河线"><br><img src="https://i.loli.net/2020/10/02/mtFzACGY7UhTHXN.jpg" srcset="/img/loading.gif" alt="大师"></p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/18 D</title>
    <link href="/2020/01/18/d/"/>
    <url>/2020/01/18/d/</url>
    
    <content type="html"><![CDATA[<p>终于回到了杭州，熟悉的地方，见到了熟悉的人。工大朝晖的风景还是很不错的，哪怕冬季还是绿意盎然。杭州的公交车司机似乎更冷漠了一些。公交车上遇到叽里呱啦的一群外地老奶奶，但欣慰的是另一辆车上也遇到杭州老奶奶在教育小孩要尊老，真好。 参加的天池比赛，这次要好好打！寒假虽然不久，但是要好好规划。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/17 D</title>
    <link href="/2020/01/17/d/"/>
    <url>/2020/01/17/d/</url>
    
    <content type="html"><![CDATA[<p>看学长跟着老师做，遇到论文润色的坑， 下次得注意。不论职场，还是学术场，有人的地方就有江湖。所幸还算了解规律。 晚上想去吃金沙江路的那家烧饼，可惜人太多，态度太差，便作罢，买了边上的一些烘焙。金沙江路倒是大变样，从原来的逼仄到现在的宽敞阔气，挺让人开心的。<img src="https://i.loli.net/2020/10/02/flZ5WwVe1QHm7Ga.jpg" srcset="/img/loading.gif" alt="宽敞的金沙江路"> 回宿舍的时候突然想去食堂看看明早开不开，但发现了意外的惊喜，挺有意思。<img src="https://i.loli.net/2020/10/02/75iYsk3nqUBLdw2.jpg" srcset="/img/loading.gif" alt="宿舍外爱心"> 本学期上海的最后一晚即将结束，准备回家咯～</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/16 Diary</title>
    <link href="/2020/01/16/diary/"/>
    <url>/2020/01/16/diary/</url>
    
    <content type="html"><![CDATA[<p>上午又去了一次医院，三乙医院还真的不行。 下午又讨论了一下学业相关事宜，徐博是真的厉害…不论改文章还是做科研，简直是个宝。一封邮件经他润色焕然一新。。。 今日补了哪吒的电影，又被煽情到了。国内电影似乎都挺煽情？哪吒，大鱼海棠，宠爱等等。哪吒的剧情在看到申公豹前往龙宫时已经猜到了大概，但这并不影响这部电影的体验。电影里的哪吒确实能激励人，但一直打这种鸡血，打多了亦无用。特别到了现在这个年纪，内在的动力才是前进力量的源头。 上海最近阴雨连绵，似是挽留想要归家的学生。可是这又有什么用呢，挽留留不住人心，大多人的根并不在这片土地上。上海或许也并不想留住我们，亦不必自作多情。 也实在是不知道内心到底想不想回家，想回家具体想的是什么。食欲不振，胃口不好，但是又还没开始收拾行李。每天去实验室，但去了也是看电影看剧。食欲与懒惰或是天气导致，或许是暂时倦了学校生活吧。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/15 Diary</title>
    <link href="/2020/01/15/diary/"/>
    <url>/2020/01/15/diary/</url>
    
    <content type="html"><![CDATA[<p>本来想去医院复诊，快走出校门了才发现没带病历本…明天早点再去吧。习惯于杭州的无纸病历，在上海还真麻烦了一点。晨间在全家买了一杯拿铁咖啡，味道就是普普通通的咖啡+奶，落肚不久才意识到我乳糖不耐受…胃里现在正发出声音（但今日最后也没拉肚子什么的，或许心理作用？）。</p><p><img src="https://i.loli.net/2020/10/02/NePryQXWxZJF1hV.jpg" srcset="/img/loading.gif" alt="全家的圣诞节遗留杯圈。杯口的扣环被我一用力掰断一部分。"></p><p>全家的小哥哥似乎是新来的，温柔高大帅气，可惜我性取向女。 逛煎蛋看到<a href="http://jandan.net/t/4441294" target="_blank" rel="noopener">一篇树洞</a>，曾经我也算是个有礼貌不爱争抢的孩子吧，得把好习惯捡起来。<a href="http://jandan.net/t/4440977" target="_blank" rel="noopener">另一篇树洞</a>也很值得反思己身。 晚饭吃的徐博从家里带来的包子。这应该算是第二轮的包子了。第一轮的包子里有挺多梅干菜包，甚是喜欢。这次吃了两天萝卜丝肉包也有点腻了，似乎失去了一开始的感觉。餐后以2-4倍速看完了10集风平浪静的闲暇，转眼已经是十一点半余。片中我闻慎二哭的时候我的心脏似乎也在抽搐。其实看这部剧之前并不知道这部是什么类型，什么内容。但看到一半，感觉片中人的人生走向里有一些现实的折射。如果抛去为剧情营造的那么多巧合，片子中发生的故事和我18年的走向还有点相符。锥心的痛现在已经好的差不多了，往者不可谏，来者犹可追。向前吧。 凪和慎二都从往事中走了出来，而凪快刀斩乱麻的水平确实高于慎二。女性比男性成熟或许是其一。自身的经历或许是原因之二。现实又何不是如此呢。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>华师之各种洗澡方式横评</title>
    <link href="/2020/01/14/e5-8d-8e-e5-b8-88-e4-b9-8b-e5-90-84-e7-a7-8d-e6-b4-97-e6-be-a1-e6-96-b9-e5-bc-8f-e6-a8-aa-e8-af-84/"/>
    <url>/2020/01/14/e5-8d-8e-e5-b8-88-e4-b9-8b-e5-90-84-e7-a7-8d-e6-b4-97-e6-be-a1-e6-96-b9-e5-bc-8f-e6-a8-aa-e8-af-84/</url>
    
    <content type="html"><![CDATA[<p>基本分成以下几种： 1 寝室冷水澡。快乐是快乐的，天气冷起来就有点难，而且容易感冒。但如果持之以恒或许可以强身健体？ 2 寝室打热水兑冷水冲澡。优点在于足不出楼即可享受热水澡。但缺点如下：其一，桶要大，否则热水不够就很尴尬；其二，如果遇到高峰期，打热水得排队。打水本身也需要点时间，尤其是遇到出水很慢的热水器的时候。而且有的热水器水温并不高，不兑冷水的话就需要更大量的热水。 3 去健身房健身完洗澡。缺点：距离远，冬天骑车过去很冷，健身房味道也很大，得在他们营业时间内去。但优点在于热水量充足，时间充足，不用考虑额外费用。 4 河西澡堂。缺点：出水的瞬间水温不稳定，而且会受到边上阀门开关的影响。基本上是边上一开热水阀，你所在位置出水水温基本会降低到“冷”的程度，而当别人关闭阀门，你位置的水温会升高，烫你一下。但优点在于离五舍很近，从下午2/3点开到晚上11点，热水量比较充足。分两个阀门，左边的热水，右边冷水。河西的更衣柜是物理钥匙，有的钥匙可以互开，这是一个缺点，但在校内，或许还是可以信任大家的吧。整体浴室保温比较好，冬天不会冷。 5 丽娃澡堂。缺点，距离五舍很远，冬天过去真的冷。热水量也不充足，10点多去得开到最热的那边才够洗。因为算是半敞开式的浴室结构，水雾散去的很快，但也留不住温度，会比河西冷一下。单阀门，和普通家用热水器一样。钥匙是RFID，比较方便和安全。而且在丽娃路上似乎能多遇到一些女生？ 0 河东女浴室。等待谁能来写一下哈哈哈，我此生估计写不出这篇评价。 PS：河西和丽娃的收费都是2毛一分钟，而且都是只要卡在，不管水阀开了还是关了都计费。 PPS：或许有人可以开房洗澡？？？</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/14 Diary</title>
    <link href="/2020/01/14/diary/"/>
    <url>/2020/01/14/diary/</url>
    
    <content type="html"><![CDATA[<p>不知不觉一月份已经过去快一半了，过的还行。过得还算开心。这几天虽然说没有太忙，也在稳步前进。下午查了一下发现酒精是一级致癌物，每天喝大约50克酒精(约5.3个酒精单位)的人患上述癌症的风险比不饮酒的人高两至三倍。um但是快乐和健康孰轻孰重呢？烧烤也致癌。为了快乐故，俗事可以抛，适度就好。 </p><p>本学期算是圆满，赶在回家前体验了我校两个澡堂。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/13 Diary</title>
    <link href="/2020/01/13/diary/"/>
    <url>/2020/01/13/diary/</url>
    
    <content type="html"><![CDATA[<p>他们说，鸽只有一次和无数次。那今天就不鸽了吧，感觉今天的早起缺乏了动力，终日浑浑噩噩不知所措。普陀中心医院：一所三甲医院，态度和条件真的不行。 晚上看了部Joker，也学习了一点多分类和回归的内容。又在硬盘里下了完整的Slam Dunk（含剧场版），一共100G+，回家看吧~ 歇了歇了，差点今天就鸽了，还好回寝室想起来…</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>技术性Blog（伪</title>
    <link href="/2020/01/12/e6-8a-80-e6-9c-af-e6-80-a7blog-ef-bc-88-e4-bc-aa/"/>
    <url>/2020/01/12/e6-8a-80-e6-9c-af-e6-80-a7blog-ef-bc-88-e4-bc-aa/</url>
    
    <content type="html"><![CDATA[<p>荐书《Python深度学习》，人民邮电出版社，张亮译。此书非常易懂！！ Environment: Python 3.7.4 Backend: TensorFlow Python技巧: </p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np re=np.zeros((<span class="hljs-number">8</span>,<span class="hljs-number">16</span>))<span class="hljs-comment">#8行16列的矩阵，所有元素为0</span>re[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">8</span>]]=<span class="hljs-number">4</span><span class="hljs-comment">#可行，前后数量相等，等价于re[1,4]=re[2,8]=5</span>re[[<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">8</span>]]=<span class="hljs-number">5</span><span class="hljs-comment">#可行，有一个维度数量为1，怎么都可行，[x]和x等价</span>re[:,]=<span class="hljs-number">5</span><span class="hljs-comment">#可行，全部置为5 re[,]=5#不可行</span>re[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]=<span class="hljs-number">5</span> <span class="hljs-comment">#可行，第1，2行的4678列置为5</span>a=list([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<span class="hljs-keyword">for</span> index,sequence <span class="hljs-keyword">in</span> enumerate(a):<span class="hljs-comment">#枚举下标和元素值</span>    print(index,sequence)stu=&#123;‘wang’:’ba’&#125;<span class="hljs-comment">#等价于stu=dict([(‘wang’,’ ba’)])</span>stu[‘wang’]<span class="hljs-comment">#输出’ba’</span>reverse_index=dict([(value,key)<span class="hljs-keyword">for</span> (key,value) <span class="hljs-keyword">in</span> stu.items()])range(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">#取到1，2，不取3</span>A = numpy.matrix(numpy.ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))numpy.array(A)[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span> <span class="hljs-comment">#不改变A</span>numpy.asarray(A)[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span> <span class="hljs-comment">#改变A</span></code></pre><p>Keras工作流程： </p><p>(1) 定义训练数据：输入张量和目标张量。<br>(2) 定义层组成的网络（或模型），将输入映射到目标。<br>(3) 配置学习过程：选择损失函数、优化器和需要监控的指标。<br>(4) 调用模型的 fit 方法在训练数据上进行迭代。 定义模型有两种方法：一种是使用 Sequential 类（仅用于层的线性堆叠），另一种是函数式 API（ 用于层组成的有向无环图，可以构建任意形式的架构）。</p><p>写到一半发现还是暂时鸽了吧2333，后面画一个思维导图会更好讲明白一点。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/12 Diary</title>
    <link href="/2020/01/12/diary/"/>
    <url>/2020/01/12/diary/</url>
    
    <content type="html"><![CDATA[<p>今日早早醒来睡不着，反复想入睡，随之惊觉要去医院hh。骑车过去，手是真冷，早知道不把那个皮手套送人了…本以为自己用不上，结果说不定还是会用上的。普中心医院果然符合三乙之名，楼层设置不合理。医生状态也很差。还给我开了一个无用的检查，折返后取消之…为了查肝功能特意没吃早饭去的，结果说今日没人，还真是鲜见。 </p><p><img src="https://i.loli.net/2020/10/02/iTlFRHpwE6o2v3N.jpg" srcset="/img/loading.gif" alt="大闸蟹"><br><img src="https://i.loli.net/2020/10/02/k7cf8OCqEpXeVLm.jpg" srcset="/img/loading.gif" alt="分层红茶"></p><p>天空之城与守望先锋，一样的竖式指示灯，故事里都有鸟，而花朵变成了树枝。</p><p><img src="https://i.loli.net/2020/10/02/duvh9gbFtVMCTJU.png" srcset="/img/loading.gif" alt="天空之城"><br><img src="https://i.loli.net/2020/10/02/49qbQo2I1l3ngTM.png" srcset="/img/loading.gif" alt="守望先锋"></p><p>乱逛byr，这什么沙雕漫啊哈哈哈哈，下载下来看看。真就沙雕漫哈哈哈哈。 <div style="text-align:center"> <img src="https://i.loli.net/2020/10/02/kAXIxPDlCu68EJo.png" srcset="/img/loading.gif" alt="理科生"></div></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/11 Diary</title>
    <link href="/2020/01/11/diary/"/>
    <url>/2020/01/11/diary/</url>
    
    <content type="html"><![CDATA[<p>今天醒的还不算晚，早上庸庸碌碌过去了，Leetcode上写了几道题，和朋友玩了几局游戏，转眼已是下午。 下午来到实验室，别人在打游戏而我在学习。我发现我还是喜欢和别人反着来…该玩的时候学，该学的时候玩… 回顾了一下几年前看的<a href="https://www.bilibili.com/video/av850938" target="_blank" rel="noopener">地球OL</a>，当时看的可是热血沸腾，想要去做这里面的一些事情，而现在看到，心情却没有什么太大的波动了。无论是视频画质，视频内容，弹幕，都不太能打动我。以前爱看的纪录片，现在下到硬盘里，连快进都懒得按了，直接删之而后快。这也是我的改变吧。 晚上查一个名词有感。在中文世界里皓首穷经不可得的东西，换Google之后前几个就是。而前几日在Google下寻不到的结果却在百度的前几个链接里出现…搜不到的东西最好还是多换搜索引擎吧，兼听则明偏听则暗，还是很有道理的。 实验室曾有人吐槽饮水机下面的水槽每次倒完水不久就又满了，不知谁想出来的鬼才方案，直接移除水槽！学到！好一手斩草除根，断子绝孙哈哈哈哈 <img src="https://i.loli.net/2020/10/02/le7FxA6LQbUM4um.jpg" srcset="/img/loading.gif" alt="新的一年不要花过多的时间和精力去讨厌一个人.jpg">上面这个话是微博里昨天看到转的，今天就用上了。我做到了！另外，也要找到自己所爱，不要附庸风雅而去做一些自己本身没兴趣的事情。“风雅”只是让你见识到了新的东西而已，并不是一定要去做~</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/10 流水账</title>
    <link href="/2020/01/10/e6-b5-81-e6-b0-b4-e8-b4-a6/"/>
    <url>/2020/01/10/e6-b5-81-e6-b0-b4-e8-b4-a6/</url>
    
    <content type="html"><![CDATA[<p>今天炉石很开心！今天唱歌也很开心！！难得有人唱mj的歌！！开开心心!~</p><p><img src="https://i.loli.net/2020/10/02/jK4vZbAmLIWnRYo.jpg" srcset="/img/loading.gif" alt="和图形图像课的诸位开心KTV.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/09 Diary</title>
    <link href="/2020/01/09/diary/"/>
    <url>/2020/01/09/diary/</url>
    
    <content type="html"><![CDATA[<p>莫名其妙组了一场KTV，尴尬是有点尴尬…..不过薯片真好吃啊…… 当日记变成了每天的任务，记录变得无聊与乏味。日子也何尝不是这样，或许应该适应这种平淡？还是要创造不一样的新鲜感呢？不得而知。 赶回实验室交完之前的算法作业，顺便又看了一部羞羞的铁拳，有趣。这样的爱情或许也是挺有意思的。我期盼什么样的爱情呢哈哈哈</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/08 Diary</title>
    <link href="/2020/01/08/diary/"/>
    <url>/2020/01/08/diary/</url>
    
    <content type="html"><![CDATA[<p>今日断断续续看完了大鱼海棠，着实是一部不错的电影。之前没去看太可惜了，但看完1080P版本也算满足。湫有意，椿无心，动画也是现实。 无论是剧情的设计，动画效果的呈现，都堪称一流。没有椿的意外，就也不会有后面的故事。缘分这东西说不清道不明，该来的就是会来。椿真的太可爱了，喜欢！ 今明后三天连着3个KTV也真的是绝了，这叫啥生活啊。。。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2019/01/07 Diary</title>
    <link href="/2020/01/07/diary/"/>
    <url>/2020/01/07/diary/</url>
    
    <content type="html"><![CDATA[<p>今天上午考了算法，考的emm，不咋样，最后一题还是不会，啥已知3着色问题是NPC，求证7着色问题也是NPC问题。 似乎在中午或下午还是得补觉，不然晚上可能会困。 下了一本曼昆的微观经济学(<a href="http://staff.ustc.edu.cn/~lilz/stpc/caoqian%20mankiw%20e6.pdf" target="_blank" rel="noopener">中文</a>)(<a href="https://docs.google.com/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxjcHNzaXNvZGlhbWVtb3JpYWx0cnVzdHxneDo1YTcwMmMwNDRkNjNjNTky" target="_blank" rel="noopener">English</a>)，感觉还不错，十大经济学原理。等下看完来背一下。 1 How People Make Decisions 1 People face trade-offs 2 The cost of something is what you give up to get it 3 Rational people think at the margin (边际收益，边际成本) 4 People respond to incentives 2 How People Interact With Each Other 5 Trade can make everyone better off 6 Markets are usually a good way to organize economic activity 7 Governments can sometimes improve market outcomes 3 How The Economy as a Whole Works 8 A country’s standard of living depends on its ability to product goods and services 9 Prices rise when the government prints too much money 10 Society faces a short-term trade-off between inflation and unemployment 说是要背…其实就是抄了一遍… 打道回府~希望能给室友和部门里的朋友牵上红线。</p><p><a href="http://dict.youdao.com/search?q=with%20each%20other&keyfrom=chrome.extension" target="_blank" rel="noopener" title="查看完整释义">with each other</a> <a href="http://dict.youdao.com/search?q=with%20each%20other&keyfrom=chrome.extension" target="_blank" rel="noopener">详细</a>X</p><p>基本翻译</p><p>互相</p><p>网络释义</p><p><a href="http://dict.youdao.com/search?q=agree%20with%20each%20other&keyfrom=chrome.extension&le=eng" target="_blank" rel="noopener">agree with each other:</a> 彼此同意</p><p><a href="http://dict.youdao.com/search?q=help%20with%20each%20other&keyfrom=chrome.extension&le=eng" target="_blank" rel="noopener">help with each other:</a> 互相帮助</p><p><a href="http://dict.youdao.com/search?q=coordinate%20with%20each%20other&keyfrom=chrome.extension&le=eng" target="_blank" rel="noopener">coordinate with each other:</a> 互相配合</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/06 Diary</title>
    <link href="/2020/01/06/diary/"/>
    <url>/2020/01/06/diary/</url>
    
    <content type="html"><![CDATA[<p>晨起的时候突然梦到很难受的事情，又睡下。一小时回笼觉之后，天气正好，心情阴转晴啦。</p><p>@12:49 下午的组会ppt做的实在差不多了…不想改了，开始摸鱼搓炉石。明天的考试在得知是助教批改之后也不想看了，真是废。桌面上摆了一堆书，硬盘里存了好多影视和电子书，也懒得翻阅。丧。</p><p>下午的组会真的糟糕透顶…烦躁。日子没有新鲜感了。</p><p>明天考试好运~</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/05</title>
    <link href="/2020/01/05/diary/"/>
    <url>/2020/01/05/diary/</url>
    
    <content type="html"><![CDATA[<p>越到期末越懒是怎么回事。今天迟迟不肯起床，难得让室友帮忙带了早饭。饭后赶往实验室摸了一早上的鱼，下午又磨磨蹭蹭改ppt，转眼又快到了锻炼时间了…乏味的期末。双力臂有突破，3个半，悬垂举腿还是很累…哎</p><p>晚饭吃的食堂，一碗水果沙拉，并不好吃。加了什么乱七八糟的颗粒，橘子的籽也还在，水果本身味道也一般，白瞎了10元。</p><p>晚上又看了NP、P、NPC问题，感觉还是云里雾里，咋办啊…0-1背包相对简单一些，拓扑排序和迪杰斯特拉算法算是复习好了。明天的组会准备的也差不多了，日子真是越来越无聊啊。</p><p>今日运气其实害行，昨天聚餐时忘在河西三楼的伞成功找回。提醒了别人却忘了自己，可笑可笑。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/04 Diary</title>
    <link href="/2020/01/04/diary/"/>
    <url>/2020/01/04/diary/</url>
    
    <content type="html"><![CDATA[<p>嗨呀，本来今天说好好复习好好准备组会的，早上去做实验被鸽了一个，但收获20红包，另一个实验的人也迟到了，但迟到不久。善恶到头终有报，之前因一些事情没准时赴别人的约，今天也被人爽约了。 午餐又去河西三楼聚餐，不知徐博这次又掏了多少，也不知是徐博他自己出钱还是实验室经费，看起来是前者… 聚餐之后又去环球港蹭了实验室大佬的免费电影票，10人大团体…又蹭了徐博的可乐…《宠爱》不错，实验室也很棒！晚上回来还玩UNO和狼人杀。玩的倒是挺开心的，可能因为比以前多了个学妹？害，感觉算法都没时间复习，组会虽然之前准备好了，但也得再花点时间重新看看，打磨一下…明天要抓紧。 晚上回来，听到室友在哼唱<a href="https://music.163.com/#/song?id=443860" target="_blank" rel="noopener">いつも何度でも</a>这首歌，觉得很耳熟。原来是前几日在B站听过周深唱。然后去搜了一下原曲，发现还是周深唱的更好一些欸。而且这首歌居然是千与千寻里的！好听！可是19年去看千与千寻电影的时候似乎并没有太注意这首歌。闲下来补一补宫崎骏的电影和电影里的曲子吧。害，还得学英语，书买来都没怎么动过，要做的事情好多啊。 今儿也重新买了火车票，18号早上同一班车走~还是稍微早点回去吧。洗漱睡觉，明天加油。过几天再加一个归档功能吧…这几天实在是无力搞。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/03 Diary</title>
    <link href="/2020/01/03/diary/"/>
    <url>/2020/01/03/diary/</url>
    
    <content type="html"><![CDATA[<p>早上悠悠醒转，明明看着是10点，惊坐起之后一看手机才7点52，真的是头疼…出门看到白茫茫一片，PM2.5爆了。</p><p>今日复习了<a href="https://www.cnblogs.com/StartoverX/p/4608412.html" target="_blank" rel="noopener">区间图着色问题</a>，算是了解了。另外下午看了0-1背包问题和最大二分匹配的问题（二分图）。背包问题可以用<a href="https://www.kancloud.cn/kancloud/pack/70125" target="_blank" rel="noopener">状态转移方程</a>求解。二分图问题可以归约（Reduction）为最大流问题，加入一个源点和一个汇点，链接源点和汇点的每条边容量设置为正无穷，原始图里的边容量设置为1即可。再用Ford-Fulkerson方法确定最大流就可以，方便快捷。</p><p>锻炼去咯~还是依旧40余个臂屈伸+1个半双力臂+一些单杠。本来做了几个单杠看天气不太好，身体状态也一般，想走的。转念又回头，一念天堂，一念地狱吗哈哈哈。锻炼完去做了一个实验，主试小姐姐是真可爱。澡后去食堂，常见的那位阿姨并不在，便随便找了个窗口打饭。明明没有点虾，菜里却多了红色触须。定睛一看居然是一只虾！靴靴阿姨赠虾之恩，好吃！</p><p>晚上读了一下分治求逆序对。算法如下，还是比较直观的。</p><p><img src="https://i.loli.net/2020/10/02/wuPLgfEAvVb5CFl.png" srcset="/img/loading.gif" alt="分治总述.png"></p><p><img src="https://i.loli.net/2020/10/02/oOzHfeMsGlnPyN3.png" srcset="/img/loading.gif" alt="分治.png"></p><p>Merge and count 步骤如下。<br><img src="https://i.loli.net/2020/10/02/59MUCyKHnjdLXuk.png" srcset="/img/loading.gif" alt="Merge-and-count.png"></p><p>感觉这复习就像…翻书：马冬梅。合书：马什么梅。再翻书：马冬梅。合书：什么冬梅…</p><p>本来感觉1月7组会还有好几天呢，结果说改到1月6了，突然发现没有几天了。明天和实验室的人去看电影，后天周日，再一天就要组会了。组会完还得算法考试…还是得合理规划呀。One period one thing，很重要！</p><p>@22：45 打道回府咯~</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/02 Diary</title>
    <link href="/2020/01/02/diary/"/>
    <url>/2020/01/02/diary/</url>
    
    <content type="html"><![CDATA[<p>瞅了眼日期，发现有好多0哈哈哈。今日比较无聊。昨日某室友说要起床学习，而等我快9点出门的时候他还在床上哈哈哈哈。</p><p>今日把昨天没看完的网络流看了一下，最大流的手推是没问题了，每次增加流量的时候记得改反向路径，当所有增广路径都遍历完的时候要划掉之前增加的反向路径，残余网络就是最小割了。也看了一下最小生成树的Krustal算法</p><p><img src="https://i.loli.net/2020/10/02/oViREQfw3Yabumt.png" srcset="/img/loading.gif" alt="最小生成树Krustal.png"><br><img src="https://i.loli.net/2020/10/02/2T6iymujJcrsAzF.png" srcset="/img/loading.gif" alt="最小生成树Krustal2.png"></p><p>讲的不可谓不细…但我也不深究了…应付考试我觉得足够了。</p><p>大致意思就是，先定义一个空集A，每次取最小边（贪心，但在这个问题里，局部最优就是全局最优），检查这条边两端是否属于集合A中的同一棵树，如果是，该边不能加入最后的结果集合A ，如果不是，则可以加入最后的结果集合A。上图中的fhjlmn，不能成立，因为形成了环路，即这些图中不能加入的边的两端的点属于同一棵树。</p><p>考完自然辩证法啦，5点50到，7点走。回去的路上遇到室友，他和我说书上都有啊。我懵逼了，我全编的…2道题编了2页纸…编故事功夫见长，但似乎编的逐渐偏题…</p><p>回到实验室，徐博在和AC聊天，说是要Push夏阳哈哈哈，Let him focus. Focus确实是一件很重要的事儿。</p><p>今晚随便看，看到了函数式编程，racket有空可以看看。看了堆排序。算导里写着，快排性能一般会优于堆排。搜了一下原因，是<a href="https://www.zhihu.com/question/23873747" target="_blank" rel="noopener">堆排序下，数据读取的开销变大</a>。堆中，所有优先队列的操作都可以在大O(n)时间内完成。</p><p>晚上和某人聊天，提到为啥那么晚回家，陪女朋友吗？我愣了，哪来的女朋友啊哈哈哈哈。</p><p>@22：34分想到，我的很多行为是符合互联网分享精神的。回首过去一年，多少为实验室做了一些事情，搭梯子，教机场，一人吃饱实验室不愁，偶尔会带一些吃的什么来。有什么资料，有什么消息，觉得重要的就主动share。 而似乎实验室的同学并不是这样。也罢，不记。新年新开始。</p><p>想起一个道理，见人说人话，见鬼说鬼话。手机上有一款博弈游戏，叫做<a href="https://play.google.com/store/apps/details?id=com.xuangames.xrdjh" target="_blank" rel="noopener">信任的进化</a>（Google Play）。这个APP里面有两个名词很有意思，叫做复读机和复读鸭。复读机，开场合作，然后模仿对手上一轮的动作。复读鸭和复读机类似，不过会在对方连续欺骗两次后才反击，容许对方犯错。 游戏里复读鸭会活到最后。在接触这个游戏后不久，就觉得人应该做一只复读鸭（不是做鸭子哈哈哈）。去年的经历又一次加深了这个体会。好啦就安心做一只复读鸭吧。确实，我依照这样的行为准则，得到了实验室大部分人的认可。至于某些人，就随他去吧。</p><p><img src="https://i.loli.net/2020/10/02/bfaz8xHekKCFQgt.png" srcset="/img/loading.gif" alt="信任.png"></p><p>时间不早了，动身回宿舍睡觉咯~</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020/01/01 Diary 流水账</title>
    <link href="/2020/01/01/diary-e6-b5-81-e6-b0-b4-e8-b4-a6/"/>
    <url>/2020/01/01/diary-e6-b5-81-e6-b0-b4-e8-b4-a6/</url>
    
    <content type="html"><![CDATA[<p>早上拍了个日出~图书馆却没有开门，可惜可惜。在丽娃河边的长凳上沐浴了会儿阳光，又在毛像前枯黄的草坪上散了步，鞋底沾上了许许多多草叶却浑然不知，等到准备吃午饭才发现桌下都是hhh。一时间我还在疑惑这是什么，我是谁我在哪我干了什么这什么东西居然找上我了。</p><p>整个上午，一直在搓炉石，果然我还是喜欢海盗战这种卡组，还被本科朋友说太功利。但海盗战打脸真的快乐啊，我选择follow my heart！看着星星一个个多起来是真的快乐。新的一年的年初居然登上了去年年底费神费力都没有达到的等级，运气不错。</p><p>昨日（看了一下其实是1日凌晨了…）和张小7（怀疑是夜猫）随便聊了聊，今日关注了她的微博和B站，发现她居然有个Blog。进去瞄了一下，发现她拍过一些Vlog ，记录了一些影像，写了一些 Diary ，确实是个很有趣的人。也是接触到她的一些世界，让我想起来我还有这么一个服务器。明明记得之前的时候，被 GFW ban 掉了呀，当时也是因为被 ban 才换的机场。今天尝试 ping 了一下，居然能 ping 通！！！看来2020年真的是一个新的年代，开年就有好事发生！！！</p><p>去年在GoDaddy上花钱买了个域名，但怎么设置都用不了的样子。但今天在谷歌上面搜了一个中文站点，在这个站点的指导下先购买了12个月的免费域名，然后链接到服务器 ip。数分钟后域名居然成功被解析！而去年的花钱的反而完全不能欸！然后尝试安装了LNMP，成功访问。但觉得不够好，又搜索了一下WordPress，又找到一份不错的教程，也成功安装了。 发现和方丈的界面极其相近。调包侠，成了！今年是个幸运年！！！</p><p>下午的时候，按惯例登录北邮人。寻思了一番，下载剧集，观看剧集，似乎并不是我喜欢的。去年刚拿到账号不久，有点迷茫不知道要下一些什么东西，如何利用。就暂时当了一下实验室的工具人，帮几个人下了点片。今日思虑过后，选择抛弃了一些去年的习惯。北邮人Free至20：00，下载了一些书籍与资料，先存着吧，有空再看（也不知何时有空，什么叫有空。<br>对了，赠我北邮人账号的那个小伙伴似乎今日脱单了，和她在某次联谊上遇到的男生聊得很开心。据她说，那个男生很暖。她聚餐吃的胃不舒服了，会给她买各种药啊，还有热牛奶。又比如她有忌口，没有明说，却被那个男生发现，之后避开（和她8年同学的我都不知道）。替她高兴。</p><p>约3点的时候实在熬不住困，在实验室小憩。一觉醒来大概5点了，去操场锻炼了一下<del>43个臂屈伸+1个双力臂+10</del>20个单杠。发觉昨日千米左右的游泳甚是令人疲惫，手臂还会抽筋，歇着吧┑(￣Д ￣)┍<br>粗略定了一个锻炼计划，可真的是很粗略呢…但有总比没有好，不是吗？</p><p>晚上学学网络流的东西，网上搜索了半天，发现还不如看书呢~远在天边近在眼前，不要焦躁呀还是！踏实很重要。</p><p>今年也是算跨出了不一样的一步：晚睡早起看日出；一个在从前觉得什么时候都懒得动手的人，新时代居然肯动手写博客。挺好挺好，新时代就该欣欣向荣，好好保持。</p><p>上述提到的几个网站见下！简单易懂！<br><a href="http://www.freenom.com/zh/index.html?lang=zh" target="_blank" rel="noopener">http://www.freenom.com/zh/index.html?lang=zh</a><br><a href="https://www.bandwagonhost.net/3311.html" target="_blank" rel="noopener">https://www.bandwagonhost.net/3311.html</a><br><a href="https://zhuanlan.zhihu.com/p/41113434" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41113434</a></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
